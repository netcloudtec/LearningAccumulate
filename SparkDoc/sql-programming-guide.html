

<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Spark SQL and DataFrames - Spark 2.3.1 Documentation</title>




    <link rel="stylesheet" href="css/bootstrap.min.css">
    <style>
        body {
            padding-top: 60px;
            padding-bottom: 40px;
        }
    </style>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="css/bootstrap-responsive.min.css">
    <link rel="stylesheet" href="css/main.css">

    <script src="js/vendor/modernizr-2.6.1-respond-1.1.0.min.js"></script>

    <link rel="stylesheet" href="css/pygments-default.css">


    <!-- Google analytics script -->
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-32518208-2']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>


</head>
<body>
<!--[if lt IE 7]>
<p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
<![endif]-->

<!-- This code is taken from http://twitter.github.com/bootstrap/examples/hero.html -->

<div class="navbar navbar-fixed-top" id="topbar">
    <div class="navbar-inner">
        <div class="container">
            <div class="brand"><a href="index.html">
                <img src="img/spark-logo-hd.png" style="height:50px;"/></a><span class="version">2.4.0</span>
            </div>
            <ul class="nav">
                <!--TODO(andyk): Add class="active" attribute to li some how.-->
                <li><a href="index.html">Overview</a></li>

                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">编程指南<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="quick-start.html">Quick start</a></li>
                        <li><a href="rdd-programming-guide.html">RDDs, Accumulators, Broadcasts Vars</a></li>
                        <li><a href="sql-programming-guide.html">SQL, DataFrames, and Datasets</a></li>
                        <li><a href="structured-streaming-programming-guide.html">Structured Streaming</a></li>
                        <li><a href="streaming-programming-guide.html">Spark Streaming (DStreams)</a></li>
                        <li><a href="ml-guide.html">MLlib (Machine Learning)</a></li>
                        <li><a href="graphx-programming-guide.html">GraphX (Graph Processing)</a></li>
                        <li><a href="sparkr.html">SparkR (R on Spark)</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">API Docs<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="api/scala/index.html#org.apache.spark.package">Scala</a></li>
                        <li><a href="api/java/index.html">Java</a></li>
                        <li><a href="api/python/index.html">Python</a></li>
                        <li><a href="api/R/index.html">R</a></li>
                        <li><a href="api/sql/index.html">SQL, Built-in Functions</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Deploying<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="cluster-overview.html">Overview</a></li>
                        <li><a href="./latest/submitting-applications.html">Submitting Applications</a></li>
                        <li class="divider"></li>
                        <li><a href="spark-standalone.html">Spark Standalone</a></li>
                        <li><a href="running-on-mesos.html">Mesos</a></li>
                        <li><a href="running-on-yarn.html">YARN</a></li>
                        <li><a href="running-on-kubernetes.html">Kubernetes</a></li>
                    </ul>
                </li>

                <li class="dropdown">
                    <a href="api.html" class="dropdown-toggle" data-toggle="dropdown">More<b class="caret"></b></a>
                    <ul class="dropdown-menu">
                        <li><a href="configuration.html">Configuration</a></li>
                        <li><a href="monitoring.html">Monitoring</a></li>
                        <li><a href="tuning.html">Tuning Guide</a></li>
                        <li><a href="job-scheduling.html">Job Scheduling</a></li>
                        <li><a href="security.html">Security</a></li>
                        <li><a href="hardware-provisioning.html">Hardware Provisioning</a></li>
                        <li class="divider"></li>
                        <li><a href="building-spark.html">Building Spark</a></li>
                        <li><a href="http://spark.apache.org/contributing.html">Contributing to Spark</a></li>
                        <li><a href="http://spark.apache.org/third-party-projects.html">Third Party Projects</a></li>
                    </ul>
                </li>
            </ul>
            <!--<p class="navbar-text pull-right"><span class="version-text">v2.3.1</span></p>-->
        </div>
    </div>
</div>

<div class="container-wrapper">


    <div class="content" id="content">

        <h1 class="title">Spark SQL, DataFrames 和 Datasets</h1>


        <ul id="markdown-toc">
            <li><a href="#overview" id="markdown-toc-overview">概述</a>    <ul>
                <li><a href="#sql" id="markdown-toc-sql">SQL</a></li>
                <li><a href="#datasets-and-dataframes" id="markdown-toc-datasets-and-dataframes">Datasets 和 DataFrames</a></li>
            </ul>
            </li>
            <li><a href="#getting-started" id="markdown-toc-getting-started">入门指南</a>    <ul>
                <li><a href="#starting-point-sparksession" id="markdown-toc-starting-point-sparksession">起始点 : SparkSession</a></li>
                <li><a href="#creating-dataframes" id="markdown-toc-creating-dataframes">创建 DataFrames</a></li>
                <li><a href="#untyped-dataset-operations-aka-dataframe-operations" id="markdown-toc-untyped-dataset-operations-aka-dataframe-operations">无类型 Dataset 操作（aka DataFrame 操作）</a></li>
                <li><a href="#running-sql-queries-programmatically" id="markdown-toc-running-sql-queries-programmatically">以编程的方式运行 SQL 查询</a></li>
                <li><a href="#creating-datasets" id="markdown-toc-creating-datasets">创建 Datasets</a></li>
                <li><a href="#interoperating-with-rdds" id="markdown-toc-interoperating-with-rdds">RDD 的互操作性</a>        <ul>
                    <li><a href="#inferring-the-schema-using-reflection" id="markdown-toc-inferring-the-schema-using-reflection">使用反射推断 Schema</a></li>
                    <li><a href="#programmatically-specifying-the-schema" id="markdown-toc-programmatically-specifying-the-schema">以编程的方式指定 Schema</a></li>
                </ul>
                </li>
           <!--     <li><a href="#aggregations" id="markdown-toc-aggregations">Aggregations</a>        <ul>
                    <li><a href="#untyped-user-defined-aggregate-functions" id="markdown-toc-untyped-user-defined-aggregate-functions">Untyped User-Defined Aggregate Functions</a></li>
                    <li><a href="#type-safe-user-defined-aggregate-functions" id="markdown-toc-type-safe-user-defined-aggregate-functions">Type-Safe User-Defined Aggregate Functions</a></li>
                </ul>
                </li>-->
            </ul>
            </li>
            <li><a href="#data-sources" id="markdown-toc-data-sources">数据源</a>    <ul>
                <li><a href="#generic-loadsave-functions" id="markdown-toc-generic-loadsave-functions">通用的 Load/Save 函数</a>        <ul>
                    <li><a href="#manually-specifying-options" id="markdown-toc-manually-specifying-options">手动指定选项</a></li>
                    <li><a href="#run-sql-on-files-directly" id="markdown-toc-run-sql-on-files-directly">直接在文件上运行 SQL</a></li>
                    <li><a href="#save-modes" id="markdown-toc-save-modes">保存模式</a></li>
                    <li><a href="#saving-to-persistent-tables" id="markdown-toc-saving-to-persistent-tables">保存为持久化的表</a></li>
                    <!--<li><a href="#bucketing-sorting-and-partitioning" id="markdown-toc-bucketing-sorting-and-partitioning">Bucketing, Sorting and Partitioning</a></li>-->
                </ul>
                </li>
                <li><a href="#parquet-files" id="markdown-toc-parquet-files">Parquet 文件</a>        <ul>
                    <li><a href="#loading-data-programmatically" id="markdown-toc-loading-data-programmatically">                       以编程的方式加载数据</a></li>
                    <li><a href="#partition-discovery" id="markdown-toc-partition-discovery">分区发现</a></li>
                    <li><a href="#schema-merging" id="markdown-toc-schema-merging">Schema 合并</a></li>
                    <li><a href="#hive-metastore-parquet-table-conversion" id="markdown-toc-hive-metastore-parquet-table-conversion">Hive metastore Parquet 表转换</a>            <ul>
                        <li><a href="#hiveparquet-schema-reconciliation" id="markdown-toc-hiveparquet-schema-reconciliation">Hive/Parquet Schema Reconciliation</a></li>
                        <li><a href="#metadata-refreshing" id="markdown-toc-metadata-refreshing">Metadata Refreshing</a></li>
                    </ul>
                    </li>
                    <li><a href="#configuration" id="markdown-toc-configuration">配置</a></li>
                </ul>
                </li>
                <li><a href="#orc-files" id="markdown-toc-orc-files">ORC Files</a></li>
                <li><a href="#json-datasets" id="markdown-toc-json-datasets">JSON Datasets</a></li>
                <li><a href="#hive-tables" id="markdown-toc-hive-tables">Hive 表</a>        <ul>
                    <li><a href="#specifying-storage-format-for-hive-tables" id="markdown-toc-specifying-storage-format-for-hive-tables">Specifying storage format for Hive tables</a></li>
                    <li><a href="#interacting-with-different-versions-of-hive-metastore" id="markdown-toc-interacting-with-different-versions-of-hive-metastore">与不同版本的 Hive Metastore 交互</a></li>
                </ul>
                </li>
                <li><a href="#jdbc-to-other-databases" id="markdown-toc-jdbc-to-other-databases">JDBC 连接其它数据库</a></li>
                <li><a href="#troubleshooting" id="markdown-toc-troubleshooting">故障排除</a></li>
            </ul>
            </li>
            <li><a href="#performance-tuning" id="markdown-toc-performance-tuning">性能调优</a>    <ul>
                <li><a href="#caching-data-in-memory" id="markdown-toc-caching-data-in-memory">缓存数据到内存</a></li>
                <li><a href="#other-configuration-options" id="markdown-toc-other-configuration-options">其它配置选项</a></li>
                <li><a href="#broadcast-hint-for-sql-queries" id="markdown-toc-broadcast-hint-for-sql-queries">Broadcast Hint for SQL Queries</a></li>
            </ul>
            </li>
            <li><a href="#distributed-sql-engine" id="markdown-toc-distributed-sql-engine">分布式 SQL引擎</a>    <ul>
                <li><a href="#running-the-thrift-jdbcodbc-server" id="markdown-toc-running-the-thrift-jdbcodbc-server">运行 Thrift JDBC/ODBC server</a></li>
                <li><a href="#running-the-spark-sql-cli" id="markdown-toc-running-the-spark-sql-cli">运行 Spark SQL CLI</a></li>
            </ul>
            </li>
            <li><a href="#pyspark-usage-guide-for-pandas-with-apache-arrow" id="markdown-toc-pyspark-usage-guide-for-pandas-with-apache-arrow">PySpark Usage Guide for Pandas with Apache Arrow</a>    <ul>
                <li><a href="#apache-arrow-in-spark" id="markdown-toc-apache-arrow-in-spark">Apache Arrow in Spark</a>        <ul>
                    <li><a href="#ensure-pyarrow-installed" id="markdown-toc-ensure-pyarrow-installed">Ensure PyArrow Installed</a></li>
                </ul>
                </li>
                <li><a href="#enabling-for-conversion-tofrom-pandas" id="markdown-toc-enabling-for-conversion-tofrom-pandas">Enabling for Conversion to/from Pandas</a></li>
                <li><a href="#pandas-udfs-aka-vectorized-udfs" id="markdown-toc-pandas-udfs-aka-vectorized-udfs">Pandas UDFs (a.k.a. Vectorized UDFs)</a>        <ul>
                    <li><a href="#scalar" id="markdown-toc-scalar">Scalar</a></li>
                    <li><a href="#grouped-map" id="markdown-toc-grouped-map">Grouped Map</a></li>
                </ul>
                </li>
                <li><a href="#usage-notes" id="markdown-toc-usage-notes">Usage Notes</a>        <ul>
                    <li><a href="#supported-sql-types" id="markdown-toc-supported-sql-types">Supported SQL Types</a></li>
                    <li><a href="#setting-arrow-batch-size" id="markdown-toc-setting-arrow-batch-size">Setting Arrow Batch Size</a></li>
                    <li><a href="#timestamp-with-time-zone-semantics" id="markdown-toc-timestamp-with-time-zone-semantics">Timestamp with Time Zone Semantics</a></li>
                </ul>
                </li>
            </ul>
            </li>
            <li><a href="#migration-guide" id="markdown-toc-migration-guide">Migration Guide</a>    <ul>
                <li><a href="#upgrading-from-spark-sql-230-to-231-and-above" id="markdown-toc-upgrading-from-spark-sql-230-to-231-and-above">Upgrading From Spark SQL 2.3.0 to 2.3.1 and above</a></li>
                <li><a href="#upgrading-from-spark-sql-22-to-23" id="markdown-toc-upgrading-from-spark-sql-22-to-23">Upgrading From Spark SQL 2.2 to 2.3</a></li>
                <li><a href="#upgrading-from-spark-sql-21-to-22" id="markdown-toc-upgrading-from-spark-sql-21-to-22">Upgrading From Spark SQL 2.1 to 2.2</a></li>
                <li><a href="#upgrading-from-spark-sql-20-to-21" id="markdown-toc-upgrading-from-spark-sql-20-to-21">Upgrading From Spark SQL 2.0 to 2.1</a></li>
                <li><a href="#upgrading-from-spark-sql-16-to-20" id="markdown-toc-upgrading-from-spark-sql-16-to-20">Upgrading From Spark SQL 1.6 to 2.0</a></li>
                <li><a href="#upgrading-from-spark-sql-15-to-16" id="markdown-toc-upgrading-from-spark-sql-15-to-16">Upgrading From Spark SQL 1.5 to 1.6</a></li>
                <li><a href="#upgrading-from-spark-sql-14-to-15" id="markdown-toc-upgrading-from-spark-sql-14-to-15">Upgrading From Spark SQL 1.4 to 1.5</a></li>
                <li><a href="#upgrading-from-spark-sql-13-to-14" id="markdown-toc-upgrading-from-spark-sql-13-to-14">Upgrading from Spark SQL 1.3 to 1.4</a>        <ul>
                    <li><a href="#dataframe-data-readerwriter-interface" id="markdown-toc-dataframe-data-readerwriter-interface">DataFrame data reader/writer interface</a></li>
                    <li><a href="#dataframegroupby-retains-grouping-columns" id="markdown-toc-dataframegroupby-retains-grouping-columns">DataFrame.groupBy retains grouping columns</a></li>
                    <li><a href="#behavior-change-on-dataframewithcolumn" id="markdown-toc-behavior-change-on-dataframewithcolumn">Behavior change on DataFrame.withColumn</a></li>
                </ul>
                </li>
                <li><a href="#upgrading-from-spark-sql-10-12-to-13" id="markdown-toc-upgrading-from-spark-sql-10-12-to-13">Upgrading from Spark SQL 1.0-1.2 to 1.3</a>        <ul>
                    <li><a href="#rename-of-schemardd-to-dataframe" id="markdown-toc-rename-of-schemardd-to-dataframe">Rename of SchemaRDD to DataFrame</a></li>
                    <li><a href="#unification-of-the-java-and-scala-apis" id="markdown-toc-unification-of-the-java-and-scala-apis">Unification of the Java and Scala APIs</a></li>
                    <li><a href="#isolation-of-implicit-conversions-and-removal-of-dsl-package-scala-only" id="markdown-toc-isolation-of-implicit-conversions-and-removal-of-dsl-package-scala-only">Isolation of Implicit Conversions and Removal of dsl Package (Scala-only)</a></li>
                    <li><a href="#removal-of-the-type-aliases-in-orgapachesparksql-for-datatype-scala-only" id="markdown-toc-removal-of-the-type-aliases-in-orgapachesparksql-for-datatype-scala-only">Removal of the type aliases in org.apache.spark.sql for DataType (Scala-only)</a></li>
                    <li><a href="#udf-registration-moved-to-sqlcontextudf-java--scala" id="markdown-toc-udf-registration-moved-to-sqlcontextudf-java--scala">UDF Registration Moved to <code>sqlContext.udf</code> (Java &amp; Scala)</a></li>
                    <li><a href="#python-datatypes-no-longer-singletons" id="markdown-toc-python-datatypes-no-longer-singletons">Python DataTypes No Longer Singletons</a></li>
                </ul>
                </li>
                <li><a href="#compatibility-with-apache-hive" id="markdown-toc-compatibility-with-apache-hive">Compatibility with Apache Hive</a>        <ul>
                    <li><a href="#deploying-in-existing-hive-warehouses" id="markdown-toc-deploying-in-existing-hive-warehouses">Deploying in Existing Hive Warehouses</a></li>
                    <li><a href="#supported-hive-features" id="markdown-toc-supported-hive-features">Supported Hive Features</a></li>
                    <li><a href="#unsupported-hive-functionality" id="markdown-toc-unsupported-hive-functionality">Unsupported Hive Functionality</a></li>
                    <li><a href="#incompatible-hive-udf" id="markdown-toc-incompatible-hive-udf">Incompatible Hive UDF</a></li>
                </ul>
                </li>
            </ul>
            </li>
            <li><a href="#reference" id="markdown-toc-reference">Reference</a>    <ul>
                <li><a href="#data-types" id="markdown-toc-data-types">Data Types</a></li>
                <li><a href="#nan-semantics" id="markdown-toc-nan-semantics">NaN Semantics</a></li>
            </ul>
            </li>
        </ul>

        <h1 id="overview">Overview</h1>

        <p> <strong> Spark SQL</strong> 是 Spark 处理结构化数据的一个模块。 与基础的 Spark RDD API 不同, Spark SQL 提供了查询结构化数据及计算结果等信息的接口。
            在内部，Spark SQL 使用这个额外的信息去执行额外的优化，有几种方式可以跟 Spark SQL 进行交互，包括 SQL 和 Dataset API。
            当使用相同执行引擎进行计算时，无论使用哪种 API / 语言都可以快速的计算，
            这种统一意味着开发人员在给定的 transformation API 之间实现轻松的来回切换。</p>

        <p>该页面所有例子使用的示例数据都包含在 Spark 的发布中，并且可以使用<code>spark-shell</code>, <code>pyspark </code> ,<code>sparkR</code> 来运行。</p>


        <h2 id="sql">SQL</h2>

        <p><strong> Spark SQL</strong>的功能之一是执行 SQL 查询。
            Spark SQL 也能够被用于从已存在的 Hive 环境中读取数据。 更多关于如何配置这个特性的信息，请参考 <a href="#hive-tables">Hive 表</a>这部分。
            当以另外的编程语言运行 SQL 时，查询结果将以 <a href="#datasets-and-dataframes">Dataset/DataFrame</a>的形式返回。
            您也可以使用
           <a href="#running-the-spark-sql-cli">command-line</a>
            或者 <a href="#running-the-thrift-jdbcodbc-server">JDBC/ODBC</a>与 SQL交互。</p>

        <h2 id="datasets-and-dataframes">RDD vs DataFrames vs Datasets </h2>
        <p> <strong>共性：</strong></p>
        <p>  1、RDD、DataFrame、Dataset全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利。</p>

        <p> 2、三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach时，三者才会开始遍历运算</p>
        <p>一个 <strong>Dataset</strong> 是一个分布式的数据集合。Dataset 是在 Spark 1.6 中被添加的新接口，它提供了 RDD 的优点（强类型化，能够使用强大的 lambda 函数）和 Spark SQL 优化的执行引擎的好处。
            一个 Dataset 可以从 JVM 对象来构造并且使用转换功能（map，flatMap，filter，等等）。Dataset API 在 Scala 和 Java 中是可用的。Python 不支持 Dataset API。但是由于 Python 的动态特性，许多 Dataset API 的有点已经可用了（也就是说，你可能通过 name 天生的 row.columnName 属性访问一行中的字段）。这种情况和 R 相似。
       </p>
        <p> <strong>区别：</strong></p>
        <img src="img/rdd-dataframe.png">

        <p>从上面的图中可以看出DataFrame和RDD的区别。RDD是分布式的 Java对象的集合，比如，RDD[Person]是以Person为类型参数，但是，Person类的内部结构对于RDD而言却是不可知的。DataFrame是一种以RDD为基础的分布式数据集，也就是分布式的Row对象的集合（每个Row对象代表一行记录），提供了详细的结构信息，也就是我们经常说的模式（schema），Spark SQL可以清楚地知道该数据集中包含哪些列、每列的名称和类型。
            和RDD一样，DataFrame的各种变换操作也采用惰性机制，只是记录了各种转换的逻辑转换路线图（是一个DAG图），不会发生真正的计算，这个DAG图相当于一个逻辑查询计划，最终，会被翻译成物理查询计划，生成RDD DAG，按照之前介绍的RDD DAG的执行方式去完成最终的计算得到结果。
        </p>

        <p>RDD每一个record为一个java对象。<br>
            DataFrame每个Record为Row对象，每个Row存着每个对象的属性值。<br>
            Dataset可以认为是DataFrame的一个特例，主要区别是Dataset每一个record存储的是一个强类型对象而不是一个Row。包括scheme信息。 </p>
        <p> peoples  res20: org.apache.spark.rdd.RDD[People] = MapPartitionsRDD[2] at map at <br>
            res1: org.apache.spark.sql.Dataset[People] = [a: string, b: string ... 2 more fields] <br>
            res0: org.apache.spark.sql.DataFrame = [a: string, b: string ... 2 more fields]
        </p>


        <h1 id="getting-started">入门指南</h1>

        <h2 id="starting-point-sparksession">起始点 : SparkSession</h2>

        <div class="codetabs">
            <div data-lang="scala">
                <p>  Spark 中所有功能的入口点是  <a href="api/scala/index.html#org.apache.spark.sql.SparkSession"><code>SparkSession</code></a>  类。去创建一个基本的 SparkSession，仅使用<code>SparkSession.builder()</code>:</p>
                <div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span>

<span class="k">val</span> <span class="n">spark</span> <span class="k">=</span> <span class="nc">SparkSession</span>
  <span class="o">.</span><span class="n">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="n">appName</span><span class="o">(</span><span class="s">&quot;Spark SQL basic example&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">config</span><span class="o">(</span><span class="s">&quot;spark.some.config.option&quot;</span><span class="o">,</span> <span class="s">&quot;some-value&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">getOrCreate</span><span class="o">()</span>

<span class="c1">// For implicit conversions like converting RDDs to DataFrames</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>
</pre></div>
                <div><small>在 "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" 下查看完整代码。</small></div>
            </div>

            <div data-lang="java">

                <p>The entry point into all functionality in Spark is the <a href="api/java/index.html#org.apache.spark.sql.SparkSession"><code>SparkSession</code></a> class. To create a basic <code>SparkSession</code>, just use <code>SparkSession.builder()</code>:</p>

                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span><span class="o">;</span>

<span class="n">SparkSession</span> <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span>
  <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">appName</span><span class="o">(</span><span class="s">&quot;Java Spark SQL basic example&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">config</span><span class="o">(</span><span class="s">&quot;spark.some.config.option&quot;</span><span class="o">,</span> <span class="s">&quot;some-value&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">getOrCreate</span><span class="o">();</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">

                <p>The entry point into all functionality in Spark is the <a href="api/python/pyspark.sql.html#pyspark.sql.SparkSession"><code>SparkSession</code></a> class. To create a basic <code>SparkSession</code>, just use <code>SparkSession.builder</code>:</p>

                <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span>

<span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span> \
    <span class="o">.</span><span class="n">builder</span> \
    <span class="o">.</span><span class="n">appName</span><span class="p">(</span><span class="s2">&quot;Python Spark SQL basic example&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="s2">&quot;spark.some.config.option&quot;</span><span class="p">,</span> <span class="s2">&quot;some-value&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">

                <p>The entry point into all functionality in Spark is the <a href="api/R/sparkR.session.html"><code>SparkSession</code></a> class. To initialize a basic <code>SparkSession</code>, just call <code>sparkR.session()</code>:</p>

                <div class="highlight"><pre><span></span>sparkR.session<span class="p">(</span>appName <span class="o">=</span> <span class="s">&quot;R Spark SQL basic example&quot;</span><span class="p">,</span> sparkConfig <span class="o">=</span> <span class="kt">list</span><span class="p">(</span>spark.some.config.option <span class="o">=</span> <span class="s">&quot;some-value&quot;</span><span class="p">))</span>
</pre></div>
                <div><small>在"examples/src/main/r/RSparkSQLExample.R" 查看完整代码。</small></div>

                <p>Note that when invoked for the first time, <code>sparkR.session()</code> initializes a global <code>SparkSession</code> singleton instance, and always returns a reference to this instance for successive invocations. In this way, users only need to initialize the <code>SparkSession</code> once, then SparkR functions like <code>read.df</code> will be able to access this global instance implicitly, and users don&#8217;t need to pass the <code>SparkSession</code> instance around.</p>
            </div>
        </div>

        <p>在 Spark 2.0 中 <code>SparkSession</code> 为 Hive 特性提供了内嵌的支持，包括使用 HiveQL 编写查询的能力，访问 Hive UDF，以及从 Hive 表中读取数据的能力。为了使用这些特性，你不需要去有一个已存在的 Hive 设置。</p>

        <h2 id="creating-dataframes">创建DataFrames</h2>

        <div class="codetabs">
            <div data-lang="scala">
                <p>有了<code>SparkSession</code>, 应用程序可以从一个 已存在的 RDD，或者一个 Hive 表中，或者从 Spark 数据源 中创建 DataFrame。
                   </p>

                <p>举个例子，下面基于一个 JSON 文件的内容创建一个 DataFrame :

                </p>

                <div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">df</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">)</span>

<span class="c1">// 显示DataFrame的内容</span>
<span class="n">df</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>完整的代码路径:"examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala"</small></div>
            </div>

            <div data-lang="java">
                <p>With a <code>SparkSession</code>, applications can create DataFrames from an <a href="#interoperating-with-rdds">existing <code>RDD</code></a>,
                    from a Hive table, or from <a href="#data-sources">Spark data sources</a>.</p>

                <p>As an example, the following creates a DataFrame based on the content of a JSON file:</p>

                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>

<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">);</span>

<span class="c1">// Displays the content of the DataFrame to stdout</span>
<span class="n">df</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <p>With a <code>SparkSession</code>, applications can create DataFrames from an <a href="#interoperating-with-rdds">existing <code>RDD</code></a>,
                    from a Hive table, or from <a href="#data-sources">Spark data sources</a>.</p>

                <p>As an example, the following creates a DataFrame based on the content of a JSON file:</p>

                <div class="highlight"><pre><span></span><span class="c1"># spark is an existing SparkSession</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">)</span>
<span class="c1"># Displays the content of the DataFrame to stdout</span>
<span class="n">df</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># | age|   name|</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># |null|Michael|</span>
<span class="c1"># |  30|   Andy|</span>
<span class="c1"># |  19| Justin|</span>
<span class="c1"># +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <p>With a <code>SparkSession</code>, applications can create DataFrames from a local R data.frame,
                    from a Hive table, or from <a href="#data-sources">Spark data sources</a>.</p>

                <p>As an example, the following creates a DataFrame based on the content of a JSON file:</p>

                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> read.json<span class="p">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">)</span>

<span class="c1"># Displays the content of the DataFrame</span>
<span class="kp">head</span><span class="p">(</span>df<span class="p">)</span>
<span class="c1">##   age    name</span>
<span class="c1">## 1  NA Michael</span>
<span class="c1">## 2  30    Andy</span>
<span class="c1">## 3  19  Justin</span>

<span class="c1"># Another method to print the first few rows and optionally truncate the printing of long values</span>
showDF<span class="p">(</span>df<span class="p">)</span>
<span class="c1">## +----+-------+</span>
<span class="c1">## | age|   name|</span>
<span class="c1">## +----+-------+</span>
<span class="c1">## |null|Michael|</span>
<span class="c1">## |  30|   Andy|</span>
<span class="c1">## |  19| Justin|</span>
<span class="c1">## +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>
        </div>

        <h2 id="untyped-dataset-operations-aka-dataframe-operations">无类型 Dataset 操作（aka DataFrame 操作）</h2>

        <p>DataFrame 提供了一个 DSL（domain-specific language）用于在 Scala，Java，Python 或者 R 中的结构化数据操作</p>

<p>正如上面提到的一样，在Spark 2.0 ，Scala 和 JavaAPI 中的 DataFrame 仅仅是多个 Row（行）的 Dataset 。这些操作也参考了与强类型的 Scala/Java Datasets 的 “类型转换” 相对应的 “无类型转换”。</p>
        <p>这里包括一些使用 Dataset 进行结构化数据处理的示例 :</p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="c1">// This import is needed to use the $-notation</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>
<span class="c1">// Print the schema in a tree format</span>
<span class="n">df</span><span class="o">.</span><span class="n">printSchema</span><span class="o">()</span>
<span class="c1">// root</span>
<span class="c1">// |-- age: long (nullable = true)</span>
<span class="c1">// |-- name: string (nullable = true)</span>

<span class="c1">// Select only the &quot;name&quot; column</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +-------+</span>
<span class="c1">// |   name|</span>
<span class="c1">// +-------+</span>
<span class="c1">// |Michael|</span>
<span class="c1">// |   Andy|</span>
<span class="c1">// | Justin|</span>
<span class="c1">// +-------+</span>

<span class="c1">// Select everybody, but increment the age by 1</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="n">$</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="n">$</span><span class="s">&quot;age&quot;</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +-------+---------+</span>
<span class="c1">// |   name|(age + 1)|</span>
<span class="c1">// +-------+---------+</span>
<span class="c1">// |Michael|     null|</span>
<span class="c1">// |   Andy|       31|</span>
<span class="c1">// | Justin|       20|</span>
<span class="c1">// +-------+---------+</span>

<span class="c1">// Select people older than 21</span>
<span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">$</span><span class="s">&quot;age&quot;</span> <span class="o">&gt;</span> <span class="mi">21</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +---+----+</span>
<span class="c1">// |age|name|</span>
<span class="c1">// +---+----+</span>
<span class="c1">// | 30|Andy|</span>
<span class="c1">// +---+----+</span>

<span class="c1">// Count people by age</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="n">count</span><span class="o">().</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+-----+</span>
<span class="c1">// | age|count|</span>
<span class="c1">// +----+-----+</span>
<span class="c1">// |  19|    1|</span>
<span class="c1">// |null|    1|</span>
<span class="c1">// |  30|    1|</span>
<span class="c1">// +----+-----+</span>
</pre></div>
                <div><small>所有的示例代码可以在 Spark repo 的 "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" 下</small></div>

                <p>能够在 DataFrame 上被执行的操作类型的完整列表请参考 <a href="api/scala/index.html#org.apache.spark.sql.Dataset">API 文档</a>。</p>

                <p>除了简单的列引用和表达式之外，DataFrame 也有丰富的函数库，包括 string 操作，date 算术，常见的 math 操作以及更多。可用的完整列表请参考 DataFrame 函数。 <a href="api/scala/index.html#org.apache.spark.sql.functions$">DataFrame 函数参考</a>。</p>
            </div>

            <div data-lang="java">

                <div class="highlight"><pre><span></span><span class="c1">// col(&quot;...&quot;) is preferable to df.col(&quot;...&quot;)</span>
<span class="kn">import static</span> <span class="nn">org.apache.spark.sql.functions.col</span><span class="o">;</span>

<span class="c1">// Print the schema in a tree format</span>
<span class="n">df</span><span class="o">.</span><span class="na">printSchema</span><span class="o">();</span>
<span class="c1">// root</span>
<span class="c1">// |-- age: long (nullable = true)</span>
<span class="c1">// |-- name: string (nullable = true)</span>

<span class="c1">// Select only the &quot;name&quot; column</span>
<span class="n">df</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +-------+</span>
<span class="c1">// |   name|</span>
<span class="c1">// +-------+</span>
<span class="c1">// |Michael|</span>
<span class="c1">// |   Andy|</span>
<span class="c1">// | Justin|</span>
<span class="c1">// +-------+</span>

<span class="c1">// Select everybody, but increment the age by 1</span>
<span class="n">df</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">col</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">),</span> <span class="n">col</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="na">plus</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +-------+---------+</span>
<span class="c1">// |   name|(age + 1)|</span>
<span class="c1">// +-------+---------+</span>
<span class="c1">// |Michael|     null|</span>
<span class="c1">// |   Andy|       31|</span>
<span class="c1">// | Justin|       20|</span>
<span class="c1">// +-------+---------+</span>

<span class="c1">// Select people older than 21</span>
<span class="n">df</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">col</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="na">gt</span><span class="o">(</span><span class="mi">21</span><span class="o">)).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +---+----+</span>
<span class="c1">// |age|name|</span>
<span class="c1">// +---+----+</span>
<span class="c1">// | 30|Andy|</span>
<span class="c1">// +---+----+</span>

<span class="c1">// Count people by age</span>
<span class="n">df</span><span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="na">count</span><span class="o">().</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +----+-----+</span>
<span class="c1">// | age|count|</span>
<span class="c1">// +----+-----+</span>
<span class="c1">// |  19|    1|</span>
<span class="c1">// |null|    1|</span>
<span class="c1">// |  30|    1|</span>
<span class="c1">// +----+-----+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>

                <p>For a complete list of the types of operations that can be performed on a Dataset refer to the <a href="api/java/org/apache/spark/sql/Dataset.html">API Documentation</a>.</p>

                <p>In addition to simple column references and expressions, Datasets also have a rich library of functions including string manipulation, date arithmetic, common math operations and more. The complete list is available in the <a href="api/java/org/apache/spark/sql/functions.html">DataFrame Function Reference</a>.</p>
            </div>

            <div data-lang="python">
                <p>In Python it&#8217;s possible to access a DataFrame&#8217;s columns either by attribute
                    (<code>df.age</code>) or by indexing (<code>df['age']</code>). While the former is convenient for
                    interactive data exploration, users are highly encouraged to use the
                    latter form, which is future proof and won&#8217;t break with column names that
                    are also attributes on the DataFrame class.</p>

                <div class="highlight"><pre><span></span><span class="c1"># spark, df are from the previous example</span>
<span class="c1"># Print the schema in a tree format</span>
<span class="n">df</span><span class="o">.</span><span class="n">printSchema</span><span class="p">()</span>
<span class="c1"># root</span>
<span class="c1"># |-- age: long (nullable = true)</span>
<span class="c1"># |-- name: string (nullable = true)</span>

<span class="c1"># Select only the &quot;name&quot; column</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +-------+</span>
<span class="c1"># |   name|</span>
<span class="c1"># +-------+</span>
<span class="c1"># |Michael|</span>
<span class="c1"># |   Andy|</span>
<span class="c1"># | Justin|</span>
<span class="c1"># +-------+</span>

<span class="c1"># Select everybody, but increment the age by 1</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +-------+---------+</span>
<span class="c1"># |   name|(age + 1)|</span>
<span class="c1"># +-------+---------+</span>
<span class="c1"># |Michael|     null|</span>
<span class="c1"># |   Andy|       31|</span>
<span class="c1"># | Justin|       20|</span>
<span class="c1"># +-------+---------+</span>

<span class="c1"># Select people older than 21</span>
<span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">21</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +---+----+</span>
<span class="c1"># |age|name|</span>
<span class="c1"># +---+----+</span>
<span class="c1"># | 30|Andy|</span>
<span class="c1"># +---+----+</span>

<span class="c1"># Count people by age</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +----+-----+</span>
<span class="c1"># | age|count|</span>
<span class="c1"># +----+-----+</span>
<span class="c1"># |  19|    1|</span>
<span class="c1"># |null|    1|</span>
<span class="c1"># |  30|    1|</span>
<span class="c1"># +----+-----+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
                <p>For a complete list of the types of operations that can be performed on a DataFrame refer to the <a href="api/python/pyspark.sql.html#pyspark.sql.DataFrame">API Documentation</a>.</p>

                <p>In addition to simple column references and expressions, DataFrames also have a rich library of functions including string manipulation, date arithmetic, common math operations and more. The complete list is available in the <a href="api/python/pyspark.sql.html#module-pyspark.sql.functions">DataFrame Function Reference</a>.</p>

            </div>

            <div data-lang="r">

                <div class="highlight"><pre><span></span><span class="c1"># Create the DataFrame</span>
df <span class="o">&lt;-</span> read.json<span class="p">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">)</span>

<span class="c1"># Show the content of the DataFrame</span>
<span class="kp">head</span><span class="p">(</span>df<span class="p">)</span>
<span class="c1">##   age    name</span>
<span class="c1">## 1  NA Michael</span>
<span class="c1">## 2  30    Andy</span>
<span class="c1">## 3  19  Justin</span>


<span class="c1"># Print the schema in a tree format</span>
printSchema<span class="p">(</span>df<span class="p">)</span>
<span class="c1">## root</span>
<span class="c1">## |-- age: long (nullable = true)</span>
<span class="c1">## |-- name: string (nullable = true)</span>

<span class="c1"># Select only the &quot;name&quot; column</span>
<span class="kp">head</span><span class="p">(</span>select<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">))</span>
<span class="c1">##      name</span>
<span class="c1">## 1 Michael</span>
<span class="c1">## 2    Andy</span>
<span class="c1">## 3  Justin</span>

<span class="c1"># Select everybody, but increment the age by 1</span>
<span class="kp">head</span><span class="p">(</span>select<span class="p">(</span>df<span class="p">,</span> df<span class="o">$</span>name<span class="p">,</span> df<span class="o">$</span>age <span class="o">+</span> <span class="m">1</span><span class="p">))</span>
<span class="c1">##      name (age + 1.0)</span>
<span class="c1">## 1 Michael          NA</span>
<span class="c1">## 2    Andy          31</span>
<span class="c1">## 3  Justin          20</span>

<span class="c1"># Select people older than 21</span>
<span class="kp">head</span><span class="p">(</span>where<span class="p">(</span>df<span class="p">,</span> df<span class="o">$</span>age <span class="o">&gt;</span> <span class="m">21</span><span class="p">))</span>
<span class="c1">##   age name</span>
<span class="c1">## 1  30 Andy</span>

<span class="c1"># Count people by age</span>
<span class="kp">head</span><span class="p">(</span>count<span class="p">(</span>groupBy<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;age&quot;</span><span class="p">)))</span>
<span class="c1">##   age count</span>
<span class="c1">## 1  19     1</span>
<span class="c1">## 2  NA     1</span>
<span class="c1">## 3  30     1</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

                <p>For a complete list of the types of operations that can be performed on a DataFrame refer to the <a href="api/R/index.html">API Documentation</a>.</p>

                <p>In addition to simple column references and expressions, DataFrames also have a rich library of functions including string manipulation, date arithmetic, common math operations and more. The complete list is available in the <a href="api/R/SparkDataFrame.html">DataFrame Function Reference</a>.</p>

            </div>

        </div>

        <h2 id="running-sql-queries-programmatically">以编程的方式运行 SQL 查询</h2>

        <div class="codetabs">
            <div data-lang="scala">
                <p>SparkSession 使应用程序的 SQL 函数能够以编程的方式运行 SQL 查询并且将查询结果以一个 DataFrame返回。
                </p>

                <div class="highlight"><pre><span></span><span class="c1">// Register the DataFrame as a SQL temporary view</span>
<span class="n">df</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">)</span>

<span class="k">val</span> <span class="n">sqlDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM people&quot;</span><span class="o">)</span>
<span class="n">sqlDF</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>完整的实例： "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" </small></div>
            </div>

            <div data-lang="java">
                <p>The <code>sql</code> function on a <code>SparkSession</code> enables applications to run SQL queries programmatically and returns the result as a <code>Dataset&lt;Row&gt;</code>.</p>

                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>

<span class="c1">// Register the DataFrame as a SQL temporary view</span>
<span class="n">df</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">);</span>

<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">sqlDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM people&quot;</span><span class="o">);</span>
<span class="n">sqlDF</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <p>The <code>sql</code> function on a <code>SparkSession</code> enables applications to run SQL queries programmatically and returns the result as a <code>DataFrame</code>.</p>

                <div class="highlight"><pre><span></span><span class="c1"># Register the DataFrame as a SQL temporary view</span>
<span class="n">df</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;people&quot;</span><span class="p">)</span>

<span class="n">sqlDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM people&quot;</span><span class="p">)</span>
<span class="n">sqlDF</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># | age|   name|</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># |null|Michael|</span>
<span class="c1"># |  30|   Andy|</span>
<span class="c1"># |  19| Justin|</span>
<span class="c1"># +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <p>The <code>sql</code> function enables applications to run SQL queries programmatically and returns the result as a <code>SparkDataFrame</code>.</p>

                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> sql<span class="p">(</span><span class="s">&quot;SELECT * FROM table&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>
        </div>

        <h2 id="global-temporary-view">Global Temporary View</h2>

        <p>Spark SQL中的临时视图是会话范围的，如果创建它的会话终止，它将消失。 如果您希望拥有一个在所有会话之间共享的临时视图并保持活动状态，直到Spark应用程序终止，您可以创建一个全局临时视图。 全局临时视图与系统保留的数据库global_temp绑定，我们必须使用限定名称来引用它，例如 SELECT * FROM global_temp.view1。</p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="c1">// Register the DataFrame as a global temporary view</span>
<span class="n">df</span><span class="o">.</span><span class="n">createGlobalTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">)</span>

<span class="c1">// Global temporary view is tied to a system preserved database `global_temp`</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM global_temp.people&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>

<span class="c1">// Global temporary view is cross-session</span>
<span class="n">spark</span><span class="o">.</span><span class="n">newSession</span><span class="o">().</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM global_temp.people&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>在spark repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala"查看完整的代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="c1">// Register the DataFrame as a global temporary view</span>
<span class="n">df</span><span class="o">.</span><span class="na">createGlobalTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">);</span>

<span class="c1">// Global temporary view is tied to a system preserved database `global_temp`</span>
<span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM global_temp.people&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>

<span class="c1">// Global temporary view is cross-session</span>
<span class="n">spark</span><span class="o">.</span><span class="na">newSession</span><span class="o">().</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM global_temp.people&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="c1"># Register the DataFrame as a global temporary view</span>
<span class="n">df</span><span class="o">.</span><span class="n">createGlobalTempView</span><span class="p">(</span><span class="s2">&quot;people&quot;</span><span class="p">)</span>

<span class="c1"># Global temporary view is tied to a system preserved database `global_temp`</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM global_temp.people&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># | age|   name|</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># |null|Michael|</span>
<span class="c1"># |  30|   Andy|</span>
<span class="c1"># |  19| Justin|</span>
<span class="c1"># +----+-------+</span>

<span class="c1"># Global temporary view is cross-session</span>
<span class="n">spark</span><span class="o">.</span><span class="n">newSession</span><span class="p">()</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM global_temp.people&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># | age|   name|</span>
<span class="c1"># +----+-------+</span>
<span class="c1"># |null|Michael|</span>
<span class="c1"># |  30|   Andy|</span>
<span class="c1"># |  19| Justin|</span>
<span class="c1"># +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">GLOBAL</span> <span class="k">TEMPORARY</span> <span class="k">VIEW</span> <span class="n">temp_view</span> <span class="k">AS</span> <span class="k">SELECT</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">FROM</span> <span class="n">tbl</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">global_temp</span><span class="p">.</span><span class="n">temp_view</span></code></pre></figure>

            </div>
        </div>

        <h2 id="creating-datasets">Creating Datasets</h2>

        <p>Dataset 与 RDD 相似，但是，他们不使用 Java 序列化或者 Kryo序列化，他们使用专门的 Encoder（编码器） 来序列化对象
            以便通过网络进行处理或传输。
            虽然编码器和标准的序列化都负责将一个对象序列化成字节，但编码器是动态生成的代码，
            并使用一种格式，允许Spark执行许多操作，如过滤，排序和散列，而无需将字节反序列化为对象。</p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span
                        class="nc">Person</span><span class="o">(</span><span class="n">name</span><span
                        class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span
                        class="n">age</span><span class="k">:</span> <span class="kt">Long</span><span
                        class="o">)</span>

<span class="c1">// Encoders are created for case classes</span>
<span class="k">val</span> <span class="n">caseClassDS</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Andy&quot;</span><span class="o">,</span> <span class="mi">32</span><span class="o">)).</span><span class="n">toDS</span><span class="o">()</span>
<span class="n">caseClassDS</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+---+</span>
<span class="c1">// |name|age|</span>
<span class="c1">// +----+---+</span>
<span class="c1">// |Andy| 32|</span>
<span class="c1">// +----+---+</span>

<span class="c1">// Encoders for most common types are automatically provided by importing spark.implicits._</span>
<span class="k">val</span> <span class="n">primitiveDS</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">toDS</span><span class="o">()</span>
<span class="n">primitiveDS</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">collect</span><span class="o">()</span> <span class="c1">// Returns: Array(2, 3, 4)</span>

<span class="c1">// DataFrames can be converted to a Dataset by providing a class. Mapping will be done by name</span>
<span class="k">val</span> <span class="n">path</span> <span class="k">=</span> <span class="s">&quot;examples/src/main/resources/people.json&quot;</span>
<span class="k">val</span> <span class="n">peopleDS</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="n">path</span><span class="o">).</span><span class="n">as</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span>
<span class="n">peopleDS</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>在 Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" 可以查看完整的代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Collections</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.MapFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoders</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Create an instance of a Bean class</span>
<span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
<span class="n">person</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;Andy&quot;</span><span class="o">);</span>
<span class="n">person</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">32</span><span class="o">);</span>

<span class="c1">// Encoders are created for Java beans</span>
<span class="n">Encoder</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">personEncoder</span> <span class="o">=</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">javaBeanDS</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataset</span><span class="o">(</span>
  <span class="n">Collections</span><span class="o">.</span><span class="na">singletonList</span><span class="o">(</span><span class="n">person</span><span class="o">),</span>
  <span class="n">personEncoder</span>
<span class="o">);</span>
<span class="n">javaBeanDS</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +---+----+</span>
<span class="c1">// |age|name|</span>
<span class="c1">// +---+----+</span>
<span class="c1">// | 32|Andy|</span>
<span class="c1">// +---+----+</span>

<span class="c1">// Encoders for most common types are provided in class Encoders</span>
<span class="n">Encoder</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">integerEncoder</span> <span class="o">=</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">INT</span><span class="o">();</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">primitiveDS</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataset</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="n">integerEncoder</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">transformedDS</span> <span class="o">=</span> <span class="n">primitiveDS</span><span class="o">.</span><span class="na">map</span><span class="o">(</span>
    <span class="o">(</span><span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;)</span> <span class="n">value</span> <span class="o">-&gt;</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">integerEncoder</span><span class="o">);</span>
<span class="n">transformedDS</span><span class="o">.</span><span class="na">collect</span><span class="o">();</span> <span class="c1">// Returns [2, 3, 4]</span>

<span class="c1">// DataFrames can be converted to a Dataset by providing a class. Mapping based on name</span>
<span class="n">String</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">;</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">peopleDS</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="n">path</span><span class="o">).</span><span class="na">as</span><span class="o">(</span><span class="n">personEncoder</span><span class="o">);</span>
<span class="n">peopleDS</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// | age|   name|</span>
<span class="c1">// +----+-------+</span>
<span class="c1">// |null|Michael|</span>
<span class="c1">// |  30|   Andy|</span>
<span class="c1">// |  19| Justin|</span>
<span class="c1">// +----+-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>
        </div>

        <h2 id="interoperating-with-rdds">RDD 的互操作性</h2>

        <p>Spark SQL 支持两种不同的方法用于转换已存在的 RDD 成为 Dataset。</p>
        <p>第一种方法是使用反射去推断一个包含指定的对象类型的 RDD 的 Schema。在你的 Spark 应用程序中当你已知 Schema 时这个基于方法的反射可以让你的代码更简洁。</p>
        <p>第二种用于创建 Dataset 的方法是通过一个允许你构造一个 Schema 然后把它应用到一个已存在的 RDD 的编程接口。然而这种方法更繁琐，当列和它们的类型知道运行时都是未知时它允许你去构造 Dataset。</p>

        <h3 id="inferring-the-schema-using-reflection">使用反射推断 Schema (通过样例类)</h3>
        <div class="codetabs">

            <div data-lang="scala">

                <p>Spark SQL 的 Scala 接口支持自动转换一个包含 case classes 的 RDD 为 DataFrame。
                    Case class 定义了表的 Schema。Case class 的参数名使用反射读取并且成为了列名。
                    Case class 也可以是嵌套的或者包含像 SeqS 或者 ArrayS 这样的复杂类型。
                    这个 RDD 能够被隐式转换成一个 DataFrame 然后被注册为一个表。表可以用于后续的 SQL 语句。
                </p>

                <div class="highlight"><pre><span></span><span class="c1">// 将一个RDD隐式转换为一个DataFrames</span>
<p>case class Person(name: String, age: Long)</p>

<span class="k">import</span> <span class="nn">spark.implicits._</span>

<span class="c1">// 从一个文本文件中创建一个People对象类型的RDD,然后将其转为DataFrame。 spark.sparkContext 得到sparkContext对象。</span>
<span class="k">val</span> <span class="n">peopleDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>
  <span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.txt&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">))</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">attributes</span> <span class="k">=&gt;</span> <span class="nc">Person</span><span class="o">(</span><span class="n">attributes</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">attributes</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">trim</span><span class="o">.</span><span class="n">toInt</span><span class="o">))</span>
  <span class="o">.</span><span class="n">toDF</span><span class="o">()</span>
<span class="c1">// 将此DataFrame注册为一个临时的视图 以便后面使用这个视图进行查询操作。</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">)</span>

<span class="c1">// 可以使用Spark提供的sql方法运行SQL语句</span>
<span class="k">val</span> <span class="n">teenagersDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT name, age FROM people WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">)</span>

<span class="c1">// 结果中的行的列可以通过字段索引访问。</span>
<span class="n">teenagersDF</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">teenager</span> <span class="k">=&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">teenager</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>

<span class="c1">// 或者通过字段名称进行访问。</span>
<span class="n">teenagersDF</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">teenager</span> <span class="k">=&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">teenager</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;name&quot;</span><span class="o">)).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>

<span class="c1">// No pre-defined encoders for Dataset[Map[K,V]], define explicitly</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">mapEncoder</span> <span class="k">=</span> <span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="nc">Encoders</span><span class="o">.</span><span class="n">kryo</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span>
<span class="c1">// Primitive types and case classes can be also defined as</span>
<span class="c1">// implicit val stringIntMapEncoder: Encoder[Map[String, Any]] = ExpressionEncoder()</span>

<span class="c1">// row.getValuesMap[T] retrieves multiple columns at once into a Map[String, T]</span>
<span class="n">teenagersDF</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">teenager</span> <span class="k">=&gt;</span> <span class="n">teenager</span><span class="o">.</span><span class="n">getValuesMap</span><span class="o">[</span><span class="kt">Any</span><span class="o">](</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span><span class="o">))).</span><span class="n">collect</span><span class="o">()</span>
<span class="c1">// Array(Map(&quot;name&quot; -&gt; &quot;Justin&quot;, &quot;age&quot; -&gt; 19))</span>
</pre></div>
                <div><small>在Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala"可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">

                <p>Spark SQL supports automatically converting an RDD of
                    <a href="http://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly">JavaBeans</a> into a DataFrame.
                    The <code>BeanInfo</code>, obtained using reflection, defines the schema of the table. Currently, Spark SQL
                    does not support JavaBeans that contain <code>Map</code> field(s). Nested JavaBeans and <code>List</code> or <code>Array</code>
                    fields are supported though. You can create a JavaBean by creating a class that implements
                    Serializable and has getters and setters for all of its fields.</p>

                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaRDD</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.Function</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.MapFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoders</span><span class="o">;</span>

<span class="c1">// Create an RDD of Person objects from a text file</span>
<span class="n">JavaRDD</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">peopleRDD</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">()</span>
  <span class="o">.</span><span class="na">textFile</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.txt&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">javaRDD</span><span class="o">()</span>
  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">);</span>
    <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="o">();</span>
    <span class="n">person</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="n">person</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">trim</span><span class="o">()));</span>
    <span class="k">return</span> <span class="n">person</span><span class="o">;</span>
  <span class="o">});</span>

<span class="c1">// Apply a schema to an RDD of JavaBeans to get a DataFrame</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">peopleDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataFrame</span><span class="o">(</span><span class="n">peopleRDD</span><span class="o">,</span> <span class="n">Person</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// Register the DataFrame as a temporary view</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">);</span>

<span class="c1">// SQL statements can be run by using the sql methods provided by spark</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">teenagersDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM people WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">);</span>

<span class="c1">// The columns of a row in the result can be accessed by field index</span>
<span class="n">Encoder</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stringEncoder</span> <span class="o">=</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">STRING</span><span class="o">();</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">teenagerNamesByIndexDF</span> <span class="o">=</span> <span class="n">teenagersDF</span><span class="o">.</span><span class="na">map</span><span class="o">(</span>
    <span class="o">(</span><span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;)</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span>
    <span class="n">stringEncoder</span><span class="o">);</span>
<span class="n">teenagerNamesByIndexDF</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>

<span class="c1">// or by field name</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">teenagerNamesByFieldDF</span> <span class="o">=</span> <span class="n">teenagersDF</span><span class="o">.</span><span class="na">map</span><span class="o">(</span>
    <span class="o">(</span><span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;)</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">getAs</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">),</span>
    <span class="n">stringEncoder</span><span class="o">);</span>
<span class="n">teenagerNamesByFieldDF</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">

                <p>Spark SQL can convert an RDD of Row objects to a DataFrame, inferring the datatypes. Rows are constructed by passing a list of
                    key/value pairs as kwargs to the Row class. The keys of this list define the column names of the table,
                    and the types are inferred by sampling the whole dataset, similar to the inference that is performed on JSON files.</p>

                <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">Row</span>

<span class="n">sc</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>

<span class="c1"># Load a text file and convert each line to a Row.</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.txt&quot;</span><span class="p">)</span>
<span class="n">parts</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
<span class="n">people</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">Row</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">age</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

<span class="c1"># Infer the schema, and register the DataFrame as a table.</span>
<span class="n">schemaPeople</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">people</span><span class="p">)</span>
<span class="n">schemaPeople</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;people&quot;</span><span class="p">)</span>

<span class="c1"># SQL can be run over DataFrames that have been registered as a table.</span>
<span class="n">teenagers</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM people WHERE age &gt;= 13 AND age &lt;= 19&quot;</span><span class="p">)</span>

<span class="c1"># The results of SQL queries are Dataframe objects.</span>
<span class="c1"># rdd returns the content as an :class:`pyspark.RDD` of :class:`Row`.</span>
<span class="n">teenNames</span> <span class="o">=</span> <span class="n">teenagers</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="s2">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">teenNames</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># Name: Justin</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
            </div>

        </div>

        <h3 id="programmatically-specifying-the-schema">以编程的方式指定 Schema (通过 StructType创建的scheme应用到RDD上)</h3>

        <div class="codetabs">

            <div data-lang="scala">

                <p>当 case class 不能够在执行之前被定义（例如，records 记录的结构在一个 string 字符串中被编码了，或者一个 text 文本 dataset 将被解析并且不同的用户投影的字段是不一样的）。一个 DataFrame 可以使用下面的三步以编程的方式来创建。</p>

                <ol>
                    <li>将从文本文件中创建的原始RDD使用map函数转为ROW类型的RDD。</li>
                    <li>Step 1 被创建后，创建 Schema 表示一个 StructType(StructField(name,StringType,true),...) 匹配 RDD 中的 Rows（行）的结构。</li>
                    <li>通过 SparkSession 提供的 createDataFrame 方法应用 Schema 到 RDD 的 RowS（行）。</li>
                </ol>

                <p>示例:</p>

                <div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.sql.types._</span>

<span class="c1">// 从文本文件中创建一个原始的RDD</span>
<span class="k">val</span> <span class="n">peopleRDD</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.txt&quot;</span><span class="o">)</span>

<span class="c1">// schema以字符串形式编码</span>
<span class="k">val</span> <span class="n">schemaString</span> <span class="k">=</span> <span class="s">&quot;name age&quot;</span>

<span class="c1">// 创建一个schema </span>
<span class="k">val</span> <span class="n">fields</span> <span class="k">=</span> <span class="n">schemaString</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fieldName</span> <span class="k">=&gt;</span> <span class="nc">StructField</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="nc">StringType</span><span class="o">,</span> <span class="n">nullable</span> <span class="k">=</span> <span class="kc">true</span><span class="o">))</span>
<span class="k">val</span> <span class="n">schema</span> <span class="k">=</span> <span class="nc">StructType</span><span class="o">(</span><span class="n">fields</span><span class="o">)</span>

<span class="c1">// 转换RDD 的每行记录为一个Row对象。</span>
<span class="k">val</span> <span class="n">rowRDD</span> <span class="k">=</span> <span class="n">peopleRDD</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">))</span>
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">attributes</span> <span class="k">=&gt;</span> <span class="nc">Row</span><span class="o">(</span><span class="n">attributes</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">attributes</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">trim</span><span class="o">))</span>

<span class="c1">// 应用schema 到 RDD</span>
<span class="k">val</span> <span class="n">peopleDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="o">(</span><span class="n">rowRDD</span><span class="o">,</span> <span class="n">schema</span><span class="o">)</span>

<span class="c1">// 使用DataFrame创建一个临时视图</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">)</span>

<span class="c1">// SQL可以在使用DataFrames创建的临时视图上运行</span>
<span class="k">val</span> <span class="n">results</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM people&quot;</span><span class="o">)</span>

<span class="c1">// SQL查询的结果是DataFrames并支持所有正常的RDD操作</span>
<span class="c1">//可以通过字段索引或字段名称访问结果中行的列e</span>
<span class="n">results</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">attributes</span> <span class="k">=&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">attributes</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +-------------+</span>
<span class="c1">// |        value|</span>
<span class="c1">// +-------------+</span>
<span class="c1">// |Name: Michael|</span>
<span class="c1">// |   Name: Andy|</span>
<span class="c1">// | Name: Justin|</span>
<span class="c1">// +-------------+</span>
</pre></div>
                <div><small>在 Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala"可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">

                <p>When JavaBean classes cannot be defined ahead of time (for example,
                    the structure of records is encoded in a string, or a text dataset will be parsed and
                    fields will be projected differently for different users),
                    a <code>Dataset&lt;Row&gt;</code> can be created programmatically with three steps.</p>

                <ol>
                    <li>Create an RDD of <code>Row</code>s from the original RDD;</li>
                    <li>Create the schema represented by a <code>StructType</code> matching the structure of
                        <code>Row</code>s in the RDD created in Step 1.</li>
                    <li>Apply the schema to the RDD of <code>Row</code>s via <code>createDataFrame</code> method provided
                        by <code>SparkSession</code>.</li>
                </ol>

                <p>For example:</p>

                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.JavaRDD</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.Function</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.DataTypes</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.StructField</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.StructType</span><span class="o">;</span>

<span class="c1">// Create an RDD</span>
<span class="n">JavaRDD</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">peopleRDD</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sparkContext</span><span class="o">()</span>
  <span class="o">.</span><span class="na">textFile</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.txt&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">.</span><span class="na">toJavaRDD</span><span class="o">();</span>

<span class="c1">// The schema is encoded in a string</span>
<span class="n">String</span> <span class="n">schemaString</span> <span class="o">=</span> <span class="s">&quot;name age&quot;</span><span class="o">;</span>

<span class="c1">// Generate the schema based on the string of schema</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">StructField</span><span class="o">&gt;</span> <span class="n">fields</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">fieldName</span> <span class="o">:</span> <span class="n">schemaString</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span> <span class="o">{</span>
  <span class="n">StructField</span> <span class="n">field</span> <span class="o">=</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructField</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">StringType</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
  <span class="n">fields</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">field</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">StructType</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructType</span><span class="o">(</span><span class="n">fields</span><span class="o">);</span>

<span class="c1">// Convert records of the RDD (people) to Rows</span>
<span class="n">JavaRDD</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">rowRDD</span> <span class="o">=</span> <span class="n">peopleRDD</span><span class="o">.</span><span class="na">map</span><span class="o">((</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Row</span><span class="o">&gt;)</span> <span class="n">record</span> <span class="o">-&gt;</span> <span class="o">{</span>
  <span class="n">String</span><span class="o">[]</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">RowFactory</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">attributes</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">attributes</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">trim</span><span class="o">());</span>
<span class="o">});</span>

<span class="c1">// Apply the schema to the RDD</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">peopleDataFrame</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataFrame</span><span class="o">(</span><span class="n">rowRDD</span><span class="o">,</span> <span class="n">schema</span><span class="o">);</span>

<span class="c1">// Creates a temporary view using the DataFrame</span>
<span class="n">peopleDataFrame</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">);</span>

<span class="c1">// SQL can be run over a temporary view created using DataFrames</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM people&quot;</span><span class="o">);</span>

<span class="c1">// The results of SQL queries are DataFrames and support all the normal RDD operations</span>
<span class="c1">// The columns of a row in the result can be accessed by field index or by field name</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">namesDS</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="na">map</span><span class="o">(</span>
    <span class="o">(</span><span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;)</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span>
    <span class="n">Encoders</span><span class="o">.</span><span class="na">STRING</span><span class="o">());</span>
<span class="n">namesDS</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +-------------+</span>
<span class="c1">// |        value|</span>
<span class="c1">// +-------------+</span>
<span class="c1">// |Name: Michael|</span>
<span class="c1">// |   Name: Andy|</span>
<span class="c1">// | Name: Justin|</span>
<span class="c1">// +-------------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">

                <p>When a dictionary of kwargs cannot be defined ahead of time (for example,
                    the structure of records is encoded in a string, or a text dataset will be parsed and
                    fields will be projected differently for different users),
                    a <code>DataFrame</code> can be created programmatically with three steps.</p>

                <ol>
                    <li>Create an RDD of tuples or lists from the original RDD;</li>
                    <li>Create the schema represented by a <code>StructType</code> matching the structure of
                        tuples or lists in the RDD created in the step 1.</li>
                    <li>Apply the schema to the RDD via <code>createDataFrame</code> method provided by <code>SparkSession</code>.</li>
                </ol>

                <p>For example:</p>

                <div class="highlight"><pre><span></span><span class="c1"># Import data types</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">sc</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>

<span class="c1"># Load a text file and convert each line to a Row.</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.txt&quot;</span><span class="p">)</span>
<span class="n">parts</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
<span class="c1"># Each line is converted to a tuple.</span>
<span class="n">people</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>

<span class="c1"># The schema is encoded in a string.</span>
<span class="n">schemaString</span> <span class="o">=</span> <span class="s2">&quot;name age&quot;</span>

<span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">StructField</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">StringType</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">schemaString</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
<span class="n">schema</span> <span class="o">=</span> <span class="n">StructType</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>

<span class="c1"># Apply the schema to the RDD.</span>
<span class="n">schemaPeople</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">people</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

<span class="c1"># Creates a temporary view using the DataFrame</span>
<span class="n">schemaPeople</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;people&quot;</span><span class="p">)</span>

<span class="c1"># SQL can be run over DataFrames that have been registered as a table.</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM people&quot;</span><span class="p">)</span>

<span class="n">results</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +-------+</span>
<span class="c1"># |   name|</span>
<span class="c1"># +-------+</span>
<span class="c1"># |Michael|</span>
<span class="c1"># |   Andy|</span>
<span class="c1"># | Justin|</span>
<span class="c1"># +-------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/basic.py" in the Spark repo.</small></div>
            </div>

        </div>

        <h2 id="aggregations">Aggregations (聚合)</h2>

        <p><a href="api/scala/index.html#org.apache.spark.sql.functions$">DataFrames 内置的聚合函数</a> :
            <code>count()</code>, <code>countDistinct()</code>, <code>avg()</code>, <code>max()</code>, <code>min()</code>, 等。
            虽然这些函数是为DataFrames设计的，但Spark SQL也有类型安全的版本 其中一些在<a href="api/scala/index.html#org.apache.spark.sql.expressions.scalalang.typed$">Scala</a>和
            <a href="api/java/org/apache/spark/sql/expressions/javalang/typed.html">Java</a> 中使用强类型数据集。
            此外，用户不限于预定义的聚合函数，并且可以创建自己的聚合函数。
        </p>

        <h3 id="untyped-user-defined-aggregate-functions">无类型用户自定义聚合函数</h3>
        <p>
            用户必须扩展<a href="api/scala/index.html#org.apache.spark.sql.expressions.UserDefinedAggregateFunction">UserDefinedAggregateFunction</a>抽象类以实现自定义无类型聚合函数。 例如，用户定义的平均值可能如下所示：
        </p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.sql.</span><span class="o">{</span><span class="nc">Row</span><span class="o">,</span> <span class="nc">SparkSession</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">org.apache.spark.sql.expressions.MutableAggregationBuffer</span>
<span class="k">import</span> <span class="nn">org.apache.spark.sql.expressions.UserDefinedAggregateFunction</span>
<span class="k">import</span> <span class="nn">org.apache.spark.sql.types._</span>

<span class="k">object</span> <span class="nc">MyAverage</span> <span class="k">extends</span> <span class="nc">UserDefinedAggregateFunction</span> <span class="o">{</span>
  <span class="c1">// Data types of input arguments of this aggregate function</span>
  <span class="k">def</span> <span class="n">inputSchema</span><span class="k">:</span> <span class="kt">StructType</span> <span class="o">=</span> <span class="nc">StructType</span><span class="o">(</span><span class="nc">StructField</span><span class="o">(</span><span class="s">&quot;inputColumn&quot;</span><span class="o">,</span> <span class="nc">LongType</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
  <span class="c1">// Data types of values in the aggregation buffer</span>
  <span class="k">def</span> <span class="n">bufferSchema</span><span class="k">:</span> <span class="kt">StructType</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nc">StructType</span><span class="o">(</span><span class="nc">StructField</span><span class="o">(</span><span class="s">&quot;sum&quot;</span><span class="o">,</span> <span class="nc">LongType</span><span class="o">)</span> <span class="o">::</span> <span class="nc">StructField</span><span class="o">(</span><span class="s">&quot;count&quot;</span><span class="o">,</span> <span class="nc">LongType</span><span class="o">)</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="c1">// The data type of the returned value</span>
  <span class="k">def</span> <span class="n">dataType</span><span class="k">:</span> <span class="kt">DataType</span> <span class="o">=</span> <span class="nc">DoubleType</span>
  <span class="c1">// Whether this function always returns the same output on the identical input</span>
  <span class="k">def</span> <span class="n">deterministic</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="c1">// Initializes the given aggregation buffer. The buffer itself is a `Row` that in addition to</span>
  <span class="c1">// standard methods like retrieving a value at an index (e.g., get(), getBoolean()), provides</span>
  <span class="c1">// the opportunity to update its values. Note that arrays and maps inside the buffer are still</span>
  <span class="c1">// immutable.</span>
  <span class="k">def</span> <span class="n">initialize</span><span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">MutableAggregationBuffer</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">buffer</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="mi">0L</span>
    <span class="n">buffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="mi">0L</span>
  <span class="o">}</span>
  <span class="c1">// Updates the given aggregation buffer `buffer` with new input data from `input`</span>
  <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">MutableAggregationBuffer</span><span class="o">,</span> <span class="n">input</span><span class="k">:</span> <span class="kt">Row</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">input</span><span class="o">.</span><span class="n">isNullAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">buffer</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">input</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="n">buffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// Merges two aggregation buffers and stores the updated buffer values back to `buffer1`</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">buffer1</span><span class="k">:</span> <span class="kt">MutableAggregationBuffer</span><span class="o">,</span> <span class="n">buffer2</span><span class="k">:</span> <span class="kt">Row</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">buffer1</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">buffer1</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">buffer2</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="n">buffer1</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="n">buffer1</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">buffer2</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="c1">// Calculates the final result</span>
  <span class="k">def</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">Row</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">buffer</span><span class="o">.</span><span class="n">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// Register the function to access it</span>
<span class="n">spark</span><span class="o">.</span><span class="n">udf</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="s">&quot;myAverage&quot;</span><span class="o">,</span> <span class="nc">MyAverage</span><span class="o">)</span>

<span class="k">val</span> <span class="n">df</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/employees.json&quot;</span><span class="o">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;employees&quot;</span><span class="o">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |   name|salary|</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |Michael|  3000|</span>
<span class="c1">// |   Andy|  4500|</span>
<span class="c1">// | Justin|  3500|</span>
<span class="c1">// |  Berta|  4000|</span>
<span class="c1">// +-------+------+</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT myAverage(salary) as average_salary FROM employees&quot;</span><span class="o">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |average_salary|</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |        3750.0|</span>
<span class="c1">// +--------------+</span>
</pre></div>
                <div><small>在 Spark Repo中 examples/src/main/scala/org/apache/spark/examples/sql/UserDefinedUntypedAggregation.scala"可以查看完整的示例代码。</small></div>
            </div>
            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.expressions.MutableAggregationBuffer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.expressions.UserDefinedAggregateFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.DataType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.DataTypes</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.StructField</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.types.StructType</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyAverage</span> <span class="kd">extends</span> <span class="n">UserDefinedAggregateFunction</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">StructType</span> <span class="n">inputSchema</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">StructType</span> <span class="n">bufferSchema</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">MyAverage</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">StructField</span><span class="o">&gt;</span> <span class="n">inputFields</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">inputFields</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructField</span><span class="o">(</span><span class="s">&quot;inputColumn&quot;</span><span class="o">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">LongType</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
    <span class="n">inputSchema</span> <span class="o">=</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructType</span><span class="o">(</span><span class="n">inputFields</span><span class="o">);</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">StructField</span><span class="o">&gt;</span> <span class="n">bufferFields</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">bufferFields</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructField</span><span class="o">(</span><span class="s">&quot;sum&quot;</span><span class="o">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">LongType</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
    <span class="n">bufferFields</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructField</span><span class="o">(</span><span class="s">&quot;count&quot;</span><span class="o">,</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">LongType</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
    <span class="n">bufferSchema</span> <span class="o">=</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">createStructType</span><span class="o">(</span><span class="n">bufferFields</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// Data types of input arguments of this aggregate function</span>
  <span class="kd">public</span> <span class="n">StructType</span> <span class="nf">inputSchema</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">inputSchema</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// Data types of values in the aggregation buffer</span>
  <span class="kd">public</span> <span class="n">StructType</span> <span class="nf">bufferSchema</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">bufferSchema</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// The data type of the returned value</span>
  <span class="kd">public</span> <span class="n">DataType</span> <span class="nf">dataType</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">DoubleType</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// Whether this function always returns the same output on the identical input</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">deterministic</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// Initializes the given aggregation buffer. The buffer itself is a `Row` that in addition to</span>
  <span class="c1">// standard methods like retrieving a value at an index (e.g., get(), getBoolean()), provides</span>
  <span class="c1">// the opportunity to update its values. Note that arrays and maps inside the buffer are still</span>
  <span class="c1">// immutable.</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(</span><span class="n">MutableAggregationBuffer</span> <span class="n">buffer</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">buffer</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="n">L</span><span class="o">);</span>
    <span class="n">buffer</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="n">L</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// Updates the given aggregation buffer `buffer` with new input data from `input`</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">MutableAggregationBuffer</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">Row</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">input</span><span class="o">.</span><span class="na">isNullAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
      <span class="kt">long</span> <span class="n">updatedSum</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">input</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
      <span class="kt">long</span> <span class="n">updatedCount</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
      <span class="n">buffer</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">updatedSum</span><span class="o">);</span>
      <span class="n">buffer</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">updatedCount</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// Merges two aggregation buffers and stores the updated buffer values back to `buffer1`</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="n">MutableAggregationBuffer</span> <span class="n">buffer1</span><span class="o">,</span> <span class="n">Row</span> <span class="n">buffer2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">mergedSum</span> <span class="o">=</span> <span class="n">buffer1</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">buffer2</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="kt">long</span> <span class="n">mergedCount</span> <span class="o">=</span> <span class="n">buffer1</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">buffer2</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">buffer1</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">mergedSum</span><span class="o">);</span>
    <span class="n">buffer1</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">mergedCount</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// Calculates the final result</span>
  <span class="kd">public</span> <span class="n">Double</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">Row</span> <span class="n">buffer</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">buffer</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="n">buffer</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Register the function to access it</span>
<span class="n">spark</span><span class="o">.</span><span class="na">udf</span><span class="o">().</span><span class="na">register</span><span class="o">(</span><span class="s">&quot;myAverage&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">MyAverage</span><span class="o">());</span>

<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/employees.json&quot;</span><span class="o">);</span>
<span class="n">df</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;employees&quot;</span><span class="o">);</span>
<span class="n">df</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |   name|salary|</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |Michael|  3000|</span>
<span class="c1">// |   Andy|  4500|</span>
<span class="c1">// | Justin|  3500|</span>
<span class="c1">// |  Berta|  4000|</span>
<span class="c1">// +-------+------+</span>

<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT myAverage(salary) as average_salary FROM employees&quot;</span><span class="o">);</span>
<span class="n">result</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |average_salary|</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |        3750.0|</span>
<span class="c1">// +--------------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedUntypedAggregation.java" in the Spark repo.</small></div>
            </div>
        </div>

        <h3 id="type-safe-user-defined-aggregate-functions">类型安全的用户自定义聚合函数</h3>

        <p>
            强类型数据集的用户定义聚合围绕<a href="api/scala/index.html#org.apache.spark.sql.expressions.Aggregator">Aggregator</a>抽象类。 例如，类型安全的用户定义平均值可能如下所示：
        </p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.sql.</span><span class="o">{</span><span class="nc">Encoder</span><span class="o">,</span> <span class="nc">Encoders</span><span class="o">,</span> <span class="nc">SparkSession</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">org.apache.spark.sql.expressions.Aggregator</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Employee</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">salary</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Average</span><span class="o">(</span><span class="k">var</span> <span class="n">sum</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="k">var</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">MyAverage</span> <span class="k">extends</span> <span class="nc">Aggregator</span><span class="o">[</span><span class="kt">Employee</span>, <span class="kt">Average</span>, <span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// A zero value for this aggregation. Should satisfy the property that any b + zero = b</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Average</span> <span class="o">=</span> <span class="nc">Average</span><span class="o">(</span><span class="mi">0L</span><span class="o">,</span> <span class="mi">0L</span><span class="o">)</span>
  <span class="c1">// Combine two values to produce a new value. For performance, the function may modify `buffer`</span>
  <span class="c1">// and return it instead of constructing a new object</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="o">(</span><span class="n">buffer</span><span class="k">:</span> <span class="kt">Average</span><span class="o">,</span> <span class="n">employee</span><span class="k">:</span> <span class="kt">Employee</span><span class="o">)</span><span class="k">:</span> <span class="kt">Average</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">buffer</span><span class="o">.</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">employee</span><span class="o">.</span><span class="n">salary</span>
    <span class="n">buffer</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">buffer</span>
  <span class="o">}</span>
  <span class="c1">// Merge two intermediate values</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">b1</span><span class="k">:</span> <span class="kt">Average</span><span class="o">,</span> <span class="n">b2</span><span class="k">:</span> <span class="kt">Average</span><span class="o">)</span><span class="k">:</span> <span class="kt">Average</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">b2</span><span class="o">.</span><span class="n">sum</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="n">b2</span><span class="o">.</span><span class="n">count</span>
    <span class="n">b1</span>
  <span class="o">}</span>
  <span class="c1">// Transform the output of the reduction</span>
  <span class="k">def</span> <span class="n">finish</span><span class="o">(</span><span class="n">reduction</span><span class="k">:</span> <span class="kt">Average</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">reduction</span><span class="o">.</span><span class="n">sum</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">reduction</span><span class="o">.</span><span class="n">count</span>
  <span class="c1">// Specifies the Encoder for the intermediate value type</span>
  <span class="k">def</span> <span class="n">bufferEncoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">Average</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Encoders</span><span class="o">.</span><span class="n">product</span>
  <span class="c1">// Specifies the Encoder for the final output value type</span>
  <span class="k">def</span> <span class="n">outputEncoder</span><span class="k">:</span> <span class="kt">Encoder</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Encoders</span><span class="o">.</span><span class="n">scalaDouble</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">ds</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/employees.json&quot;</span><span class="o">).</span><span class="n">as</span><span class="o">[</span><span class="kt">Employee</span><span class="o">]</span>
<span class="n">ds</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |   name|salary|</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |Michael|  3000|</span>
<span class="c1">// |   Andy|  4500|</span>
<span class="c1">// | Justin|  3500|</span>
<span class="c1">// |  Berta|  4000|</span>
<span class="c1">// +-------+------+</span>

<span class="c1">// Convert the function to a `TypedColumn` and give it a name</span>
<span class="k">val</span> <span class="n">averageSalary</span> <span class="k">=</span> <span class="nc">MyAverage</span><span class="o">.</span><span class="n">toColumn</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&quot;average_salary&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="n">averageSalary</span><span class="o">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |average_salary|</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |        3750.0|</span>
<span class="c1">// +--------------+</span>
</pre></div>
                <div><small>在 Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/UserDefinedTypedAggregation.scala" 查看完整的示例代码。</small></div>
            </div>
            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoders</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.TypedColumn</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.expressions.Aggregator</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">salary</span><span class="o">;</span>

  <span class="c1">// Constructors, getters, setters...</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Average</span> <span class="kd">implements</span> <span class="n">Serializable</span>  <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">sum</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">count</span><span class="o">;</span>

  <span class="c1">// Constructors, getters, setters...</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyAverage</span> <span class="kd">extends</span> <span class="n">Aggregator</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">,</span> <span class="n">Average</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">// A zero value for this aggregation. Should satisfy the property that any b + zero = b</span>
  <span class="kd">public</span> <span class="n">Average</span> <span class="nf">zero</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Average</span><span class="o">(</span><span class="mi">0</span><span class="n">L</span><span class="o">,</span> <span class="mi">0</span><span class="n">L</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// Combine two values to produce a new value. For performance, the function may modify `buffer`</span>
  <span class="c1">// and return it instead of constructing a new object</span>
  <span class="kd">public</span> <span class="n">Average</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Average</span> <span class="n">buffer</span><span class="o">,</span> <span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">newSum</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">getSum</span><span class="o">()</span> <span class="o">+</span> <span class="n">employee</span><span class="o">.</span><span class="na">getSalary</span><span class="o">();</span>
    <span class="kt">long</span> <span class="n">newCount</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="n">buffer</span><span class="o">.</span><span class="na">setSum</span><span class="o">(</span><span class="n">newSum</span><span class="o">);</span>
    <span class="n">buffer</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="n">newCount</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// Merge two intermediate values</span>
  <span class="kd">public</span> <span class="n">Average</span> <span class="nf">merge</span><span class="o">(</span><span class="n">Average</span> <span class="n">b1</span><span class="o">,</span> <span class="n">Average</span> <span class="n">b2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">mergedSum</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="na">getSum</span><span class="o">()</span> <span class="o">+</span> <span class="n">b2</span><span class="o">.</span><span class="na">getSum</span><span class="o">();</span>
    <span class="kt">long</span> <span class="n">mergedCount</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">+</span> <span class="n">b2</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
    <span class="n">b1</span><span class="o">.</span><span class="na">setSum</span><span class="o">(</span><span class="n">mergedSum</span><span class="o">);</span>
    <span class="n">b1</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="n">mergedCount</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">b1</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="c1">// Transform the output of the reduction</span>
  <span class="kd">public</span> <span class="n">Double</span> <span class="nf">finish</span><span class="o">(</span><span class="n">Average</span> <span class="n">reduction</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">reduction</span><span class="o">.</span><span class="na">getSum</span><span class="o">())</span> <span class="o">/</span> <span class="n">reduction</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="c1">// Specifies the Encoder for the intermediate value type</span>
  <span class="kd">public</span> <span class="n">Encoder</span><span class="o">&lt;</span><span class="n">Average</span><span class="o">&gt;</span> <span class="nf">bufferEncoder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="n">Average</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// Specifies the Encoder for the final output value type</span>
  <span class="kd">public</span> <span class="n">Encoder</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="nf">outputEncoder</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">DOUBLE</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">Encoder</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employeeEncoder</span> <span class="o">=</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="n">Employee</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">String</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&quot;examples/src/main/resources/employees.json&quot;</span><span class="o">;</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="n">path</span><span class="o">).</span><span class="na">as</span><span class="o">(</span><span class="n">employeeEncoder</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |   name|salary|</span>
<span class="c1">// +-------+------+</span>
<span class="c1">// |Michael|  3000|</span>
<span class="c1">// |   Andy|  4500|</span>
<span class="c1">// | Justin|  3500|</span>
<span class="c1">// |  Berta|  4000|</span>
<span class="c1">// +-------+------+</span>

<span class="n">MyAverage</span> <span class="n">myAverage</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyAverage</span><span class="o">();</span>
<span class="c1">// Convert the function to a `TypedColumn` and give it a name</span>
<span class="n">TypedColumn</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">,</span> <span class="n">Double</span><span class="o">&gt;</span> <span class="n">averageSalary</span> <span class="o">=</span> <span class="n">myAverage</span><span class="o">.</span><span class="na">toColumn</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">&quot;average_salary&quot;</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">averageSalary</span><span class="o">);</span>
<span class="n">result</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |average_salary|</span>
<span class="c1">// +--------------+</span>
<span class="c1">// |        3750.0|</span>
<span class="c1">// +--------------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaUserDefinedTypedAggregation.java" in the Spark repo.</small></div>
            </div>
        </div>

        <h1 id="data-sources">数据源</h1>

        <p>Spark SQL 支持通过 DataFrame 接口操作多种数据源。一个 DataFrame 可以通过关联转换来操作，也可以被创建为一个临时的 view。
            注册一个 DataFrame 作为一个临时的 view 就可以允许你在数据集上运行 SQL 查询。
            本节介绍使用Spark数据源加载和保存数据的一般方法，然后介绍可用于内置数据源的特定选项。

        </p>

        <h2 id="generic-loadsave-functions">通用的 Load/Save 函数</h2>

        <p>在最简单的方式下，默认的数据源（parquet 除非另外配置通过spark.sql.sources.default）将会用于所有的操作。
        </p>
        <p>注意:spark.read.load("path") 可以加载任何格式的数据文件(json、parquet、csv等)。</p>
        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">usersDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/users.parquet&quot;</span><span class="o">)</span>
<span class="n">usersDF</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;favorite_color&quot;</span><span class="o">).</span><span class="n">write</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="s">&quot;namesAndFavColors.parquet&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>在Spark Repo中"examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">usersDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">load</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/users.parquet&quot;</span><span class="o">);</span>
<span class="n">usersDF</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;favorite_color&quot;</span><span class="o">).</span><span class="na">write</span><span class="o">().</span><span class="na">save</span><span class="o">(</span><span class="s">&quot;namesAndFavColors.parquet&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>"examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" </small></div>
            </div>

            <div data-lang="python">

                <div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/users.parquet&quot;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;favorite_color&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;namesAndFavColors.parquet&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">

                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> read.df<span class="p">(</span><span class="s">&quot;examples/src/main/resources/users.parquet&quot;</span><span class="p">)</span>
write.df<span class="p">(</span>select<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;favorite_color&quot;</span><span class="p">),</span> <span class="s">&quot;namesAndFavColors.parquet&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>
        </div>

        <h3 id="manually-specifying-options">手动指定选项</h3>

        <p>你也可以手动的指定数据源，并且将与你想要传递给数据源的任何额外选项一起使用。数据源由其完全限定名指定（例如 : org.apache.spark.sql.parquet），不过对于内置数据源你也可以使用它们的缩写名（json, parquet, jdbc）。使用下面这个语法可以将从任意类型数据源加载的DataFrames 转换为其他类型。</p>

        <p>加载 JSON file:</p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">peopleDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;json&quot;</span><span class="o">).</span><span class="n">load</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">)</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">select</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span><span class="o">).</span><span class="n">write</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;parquet&quot;</span><span class="o">).</span><span class="n">save</span><span class="o">(</span><span class="s">&quot;namesAndAges.parquet&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>完整的示例代码在 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" </small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">peopleDF</span> <span class="o">=</span>
  <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;json&quot;</span><span class="o">).</span><span class="na">load</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">);</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">,</span> <span class="s">&quot;age&quot;</span><span class="o">).</span><span class="na">write</span><span class="o">().</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;parquet&quot;</span><span class="o">).</span><span class="na">save</span><span class="o">(</span><span class="s">&quot;namesAndAges.parquet&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;json&quot;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;namesAndAges.parquet&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;parquet&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> read.df<span class="p">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">,</span> <span class="s">&quot;json&quot;</span><span class="p">)</span>
namesAndAges <span class="o">&lt;-</span> select<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;age&quot;</span><span class="p">)</span>
write.df<span class="p">(</span>namesAndAges<span class="p">,</span> <span class="s">&quot;namesAndAges.parquet&quot;</span><span class="p">,</span> <span class="s">&quot;parquet&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>
            </div>
        </div>

        <p>加载 CSV file :</p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">peopleDFCsv</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;csv&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;sep&quot;</span><span class="o">,</span> <span class="s">&quot;;&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;inferSchema&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;header&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.csv&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>在Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">peopleDFCsv</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;csv&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;sep&quot;</span><span class="o">,</span> <span class="s">&quot;;&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;inferSchema&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;header&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.csv&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.csv&quot;</span><span class="p">,</span>
                     <span class="n">format</span><span class="o">=</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">inferSchema</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;true&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> read.df<span class="p">(</span><span class="s">&quot;examples/src/main/resources/people.csv&quot;</span><span class="p">,</span> <span class="s">&quot;csv&quot;</span><span class="p">)</span>
namesAndAges <span class="o">&lt;-</span> select<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;age&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>
        </div>

        <h3 id="run-sql-on-files-directly">直接在文件上运行 SQL</h3>

        <p>你也可以直接在文件上运行 SQL 查询来替代使用 API 将文件加载到 DataFrame 再进行查询。(注意：parquet前缀 和 ` `  符号)  </p>

        <div class="codetabs">
            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">sqlDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM parquet.`examples/src/main/resources/users.parquet`&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>在Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">sqlDF</span> <span class="o">=</span>
  <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM parquet.`examples/src/main/resources/users.parquet`&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM parquet.`examples/src/main/resources/users.parquet`&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> sql<span class="p">(</span><span class="s">&quot;SELECT * FROM parquet.`examples/src/main/resources/users.parquet`&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>
        </div>

        <h3 id="save-modes">Save Modes （保存模式）</h3>

        <p>
            Save 操作可以使用 <code>SaveMode</code>，可以指定如何处理已经存在的数据。
            这些保存模式没有利用任何锁并且也不是原子操作。
            此外，执行<code>Overwrite</code>, 新数据写入之前会先将旧数据删除。</p>

        <table class="table">
            <tr><th>Scala/Java</th><th>Any Language</th><th>Meaning</th></tr>
            <tr>
                <td><code>SaveMode.ErrorIfExists</code> (默认)</td>
                <td><code>"error" or "errorifexists"</code> (默认)</td>
                <td>
                    将DataFrame 保存到某个数据源的时候, 如果数据存在,一个异常将会被抛出。

                </td>
            </tr>
            <tr>
                <td><code>SaveMode.Append</code></td>
                <td><code>"append"</code></td>
                <td>
                 将DataFrame保存到数据源时，如果数据/表已经存在，则DataFrame的内容应该附加到现有数据。
                </td>
            </tr>
            <tr>
                <td><code>SaveMode.Overwrite</code></td>
                <td><code>"overwrite"</code></td>
                <td>
                    覆盖模式意味着在将DataFrame保存到数据源时，如果数据/表已经存在，则原有的数据将被DataFrame的内容覆盖。
                </td>
            </tr>
            <tr>
                <td><code>SaveMode.Ignore</code></td>
                <td><code>"ignore"</code></td>
                <td>
                    忽略模式意味着在将DataFrame保存到数据源时，如果数据已存在，则预期保存操作不会保存DataFrame的内容并且不会更改现有数据。这类似于SQL中的CREATE TABLE IF NOT EXISTS。

                </td>
            </tr>
        </table>

        <h3 id="saving-to-persistent-tables">保存到持久化表</h3>

        <p>也可以使用 <code>saveAsTable</code> 命令将 <code>DataFrames</code> 作为持久表保存到Hive Metastore中。
            请注意，使用此功能不需要现有的Hive部署。
            Spark将为您创建默认的本地Hive Metastore（使用Derby）。与<code>createOrReplaceTempView</code>命令不同，
            <code>saveAsTable</code> 将实现 DataFrame 的内容并创建指向 Hive Metastore 中数据的指针。
            只要您保持与同一Metastore的连接，即使您的Spark程序重新启动后，持久表仍然存在。
            可以通过使用表的名称调用SparkSession上的table方法来创建持久表的DataFrame。</p>

        <p>对于基于文件的数据源，例如 text, parquet, json, 等。
            您可以通过路径选项指定自定义表路径，例如
            <code>df.write.option("path", "/some/path").saveAsTable("t")</code>。删除表时，将不会删除自定义表路径，并且表数据仍然存在。 If no custom table path is
            如果未指定自定义表路径，则Spark会将数据写入仓库目录下的默认表路径。删除表时，也将删除默认表路径。</p>

        <p>
            从Spark 2.1开始，持久数据源表将每个分区元数据存储在Hive Metastore中。这带来了几个好处：
        </p>

        <ul>
            <li> 由于Metastore只能返回查询所需的分区，因此不再需要在表的第一个查询中发现所有分区。</li>
            <li>现在，对于使用Datasource API 创建的表，可以使用<code>ALTER TABLE PARTITION ... SET LOCATION</code>
                等Hive DDL。</li>
        </ul>

        <p>请注意，在创建外部数据源表 具有路径选项的表）时，默认情况下不会收集分区信息。要同步Metastore中的分区信息，可以调用MSCK REPAIR TABLE。</p>

        <h3 id="bucketing-sorting-and-partitioning">Bucketing, Sorting and Partitioning</h3>

        <p>For file-based data source, it is also possible to bucket and sort or partition the output.
            Bucketing and sorting are applicable only to persistent tables:

            对于基于文件的数据源，还可以对输出进行分桶和排序或分区。 分桶和排序仅适用于持久表：</p>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="n">peopleDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">bucketBy</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="s">&quot;name&quot;</span><span class="o">).</span><span class="n">sortBy</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="n">saveAsTable</span><span class="o">(</span><span class="s">&quot;people_bucketed&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>在Spark Repo 中"examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">peopleDF</span><span class="o">.</span><span class="na">write</span><span class="o">().</span><span class="na">bucketBy</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="s">&quot;name&quot;</span><span class="o">).</span><span class="na">sortBy</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">).</span><span class="na">saveAsTable</span><span class="o">(</span><span class="s">&quot;people_bucketed&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">bucketBy</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sortBy</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">saveAsTable</span><span class="p">(</span><span class="s2">&quot;people_bucketed&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users_bucketed_by_name</span><span class="p">(</span>
  <span class="n">name</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">favorite_color</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">favorite_numbers</span> <span class="nb">array</span><span class="o">&lt;</span><span class="nb">integer</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">USING</span> <span class="n">parquet</span>
<span class="n">CLUSTERED</span> <span class="k">BY</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">INTO</span> <span class="mi">42</span> <span class="n">BUCKETS</span><span class="p">;</span></code></pre></figure>

            </div>

        </div>

        <p>分区可以在使用数据集API时与 <code>save</code> 和 <code>saveAsTable</code> 一起使用。
           </p>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="n">usersDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">partitionBy</span><span class="o">(</span><span class="s">&quot;favorite_color&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;parquet&quot;</span><span class="o">).</span><span class="n">save</span><span class="o">(</span><span class="s">&quot;namesPartByColor.parquet&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>在 Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">usersDF</span>
  <span class="o">.</span><span class="na">write</span><span class="o">()</span>
  <span class="o">.</span><span class="na">partitionBy</span><span class="o">(</span><span class="s">&quot;favorite_color&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;parquet&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="s">&quot;namesPartByColor.parquet&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="s2">&quot;favorite_color&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;parquet&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;namesPartByColor.parquet&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users_by_favorite_color</span><span class="p">(</span>
  <span class="n">name</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">favorite_color</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">favorite_numbers</span> <span class="nb">array</span><span class="o">&lt;</span><span class="nb">integer</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">USING</span> <span class="n">csv</span> <span class="n">PARTITIONED</span> <span class="k">BY</span><span class="p">(</span><span class="n">favorite_color</span><span class="p">);</span></code></pre></figure>

            </div>

        </div>

        <p>可以对同一张表使用分桶和分区:</p>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="n">usersDF</span>
  <span class="o">.</span><span class="n">write</span>
  <span class="o">.</span><span class="n">partitionBy</span><span class="o">(</span><span class="s">&quot;favorite_color&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">bucketBy</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="s">&quot;name&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">saveAsTable</span><span class="o">(</span><span class="s">&quot;users_partitioned_bucketed&quot;</span><span class="o">)</span>
</pre></div>
                <div><small>在 Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="n">peopleDF</span>
  <span class="o">.</span><span class="na">write</span><span class="o">()</span>
  <span class="o">.</span><span class="na">partitionBy</span><span class="o">(</span><span class="s">&quot;favorite_color&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">bucketBy</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="s">&quot;name&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">saveAsTable</span><span class="o">(</span><span class="s">&quot;people_partitioned_bucketed&quot;</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/users.parquet&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="n">df</span>
    <span class="o">.</span><span class="n">write</span>
    <span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="s2">&quot;favorite_color&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">bucketBy</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">saveAsTable</span><span class="p">(</span><span class="s2">&quot;people_partitioned_bucketed&quot;</span><span class="p">))</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users_bucketed_and_partitioned</span><span class="p">(</span>
  <span class="n">name</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">favorite_color</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">favorite_numbers</span> <span class="nb">array</span><span class="o">&lt;</span><span class="nb">integer</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="k">USING</span> <span class="n">parquet</span>
<span class="n">PARTITIONED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">favorite_color</span><span class="p">)</span>
<span class="n">CLUSTERED</span> <span class="k">BY</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="n">SORTED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">favorite_numbers</span><span class="p">)</span> <span class="k">INTO</span> <span class="mi">42</span> <span class="n">BUCKETS</span><span class="p">;</span></code></pre></figure>

            </div>

        </div>

        <p>
            <code>partitionBy</code>创建一个目录结构，如<a href="#partition-discovery">Partition Discovery</a> 部分所述。
            因此，它对具有高基数的列的适用性有限。
            相比之下，<code>bucketBy</code>可以在固定数量的存储桶中分配数据，并且可以在许多唯一值无限制时使用。
        </p>

        <h2 id="parquet-files">Parquet文件</h2>

        <p><a href="http://parquet.io">Parquet</a> 是一个列式存储格式的文件，被许多其他数据处理系统所支持。
            支持对 Parquet 文件的读写还可以自动的保存源数据的模式。
            在编写Parquet文件时，出于兼容性原因，所有列都会自动转换为可为空。</p>

        <h3 id="loading-data-programmatically">编程的方式加载数据。</h3>

        <p>使用上面示例中的数据：</p>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="c1">// Encoders for most common types are automatically provided by importing spark.implicits._</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>

<span class="k">val</span> <span class="n">peopleDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">)</span>

<span class="c1">// DataFrames can be saved as Parquet files, maintaining the schema information</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;people.parquet&quot;</span><span class="o">)</span>

<span class="c1">// Read in the parquet file created above</span>
<span class="c1">// Parquet files are self-describing so the schema is preserved</span>
<span class="c1">// The result of loading a Parquet file is also a DataFrame</span>
<span class="k">val</span> <span class="n">parquetFileDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;people.parquet&quot;</span><span class="o">)</span>

<span class="c1">// Parquet files can also be used to create a temporary view and then used in SQL statements</span>
<span class="n">parquetFileDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;parquetFile&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">namesDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">)</span>
<span class="n">namesDF</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">attributes</span> <span class="k">=&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">attributes</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>
</pre></div>
                <div><small>在Spark Repo中"examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.MapFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoders</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>

<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">peopleDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">);</span>

<span class="c1">// DataFrames can be saved as Parquet files, maintaining the schema information</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="na">write</span><span class="o">().</span><span class="na">parquet</span><span class="o">(</span><span class="s">&quot;people.parquet&quot;</span><span class="o">);</span>

<span class="c1">// Read in the Parquet file created above.</span>
<span class="c1">// Parquet files are self-describing so the schema is preserved</span>
<span class="c1">// The result of loading a parquet file is also a DataFrame</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">parquetFileDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">parquet</span><span class="o">(</span><span class="s">&quot;people.parquet&quot;</span><span class="o">);</span>

<span class="c1">// Parquet files can also be used to create a temporary view and then used in SQL statements</span>
<span class="n">parquetFileDF</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;parquetFile&quot;</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">namesDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM parquetFile WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">namesDS</span> <span class="o">=</span> <span class="n">namesDF</span><span class="o">.</span><span class="na">map</span><span class="o">(</span>
    <span class="o">(</span><span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;)</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="s">&quot;Name: &quot;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span>
    <span class="n">Encoders</span><span class="o">.</span><span class="na">STRING</span><span class="o">());</span>
<span class="n">namesDS</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +------------+</span>
<span class="c1">// |       value|</span>
<span class="c1">// +------------+</span>
<span class="c1">// |Name: Justin|</span>
<span class="c1">// +------------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">

                <div class="highlight"><pre><span></span><span class="n">peopleDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="s2">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">)</span>

<span class="c1"># DataFrames can be saved as Parquet files, maintaining the schema information.</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;people.parquet&quot;</span><span class="p">)</span>

<span class="c1"># Read in the Parquet file created above.</span>
<span class="c1"># Parquet files are self-describing so the schema is preserved.</span>
<span class="c1"># The result of loading a parquet file is also a DataFrame.</span>
<span class="n">parquetFile</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;people.parquet&quot;</span><span class="p">)</span>

<span class="c1"># Parquet files can also be used to create a temporary view and then used in SQL statements.</span>
<span class="n">parquetFile</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;parquetFile&quot;</span><span class="p">)</span>
<span class="n">teenagers</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM parquetFile WHERE age &gt;= 13 AND age &lt;= 19&quot;</span><span class="p">)</span>
<span class="n">teenagers</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +------+</span>
<span class="c1"># |  name|</span>
<span class="c1"># +------+</span>
<span class="c1"># |Justin|</span>
<span class="c1"># +------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">

                <div class="highlight"><pre><span></span>df <span class="o">&lt;-</span> read.df<span class="p">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="p">,</span> <span class="s">&quot;json&quot;</span><span class="p">)</span>

<span class="c1"># SparkDataFrame can be saved as Parquet files, maintaining the schema information.</span>
write.parquet<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;people.parquet&quot;</span><span class="p">)</span>

<span class="c1"># Read in the Parquet file created above. Parquet files are self-describing so the schema is preserved.</span>
<span class="c1"># The result of loading a parquet file is also a DataFrame.</span>
parquetFile <span class="o">&lt;-</span> read.parquet<span class="p">(</span><span class="s">&quot;people.parquet&quot;</span><span class="p">)</span>

<span class="c1"># Parquet files can also be used to create a temporary view and then used in SQL statements.</span>
createOrReplaceTempView<span class="p">(</span>parquetFile<span class="p">,</span> <span class="s">&quot;parquetFile&quot;</span><span class="p">)</span>
teenagers <span class="o">&lt;-</span> sql<span class="p">(</span><span class="s">&quot;SELECT name FROM parquetFile WHERE age &gt;= 13 AND age &lt;= 19&quot;</span><span class="p">)</span>
<span class="kp">head</span><span class="p">(</span>teenagers<span class="p">)</span>
<span class="c1">##     name</span>
<span class="c1">## 1 Justin</span>

<span class="c1"># We can also run custom R-UDFs on Spark DataFrames. Here we prefix all the names with &quot;Name:&quot;</span>
schema <span class="o">&lt;-</span> structType<span class="p">(</span>structField<span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="s">&quot;string&quot;</span><span class="p">))</span>
teenNames <span class="o">&lt;-</span> dapply<span class="p">(</span>df<span class="p">,</span> <span class="kr">function</span><span class="p">(</span>p<span class="p">)</span> <span class="p">{</span> <span class="kp">cbind</span><span class="p">(</span><span class="kp">paste</span><span class="p">(</span><span class="s">&quot;Name:&quot;</span><span class="p">,</span> p<span class="o">$</span>name<span class="p">))</span> <span class="p">},</span> schema<span class="p">)</span>
<span class="kr">for</span> <span class="p">(</span>teenName <span class="kr">in</span> collect<span class="p">(</span>teenNames<span class="p">)</span><span class="o">$</span>name<span class="p">)</span> <span class="p">{</span>
  <span class="kp">cat</span><span class="p">(</span>teenName<span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">## Name: Michael</span>
<span class="c1">## Name: Andy</span>
<span class="c1">## Name: Justin</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TEMPORARY</span> <span class="k">VIEW</span> <span class="n">parquetTable</span>
<span class="k">USING</span> <span class="n">org</span><span class="p">.</span><span class="n">apache</span><span class="p">.</span><span class="n">spark</span><span class="p">.</span><span class="k">sql</span><span class="p">.</span><span class="n">parquet</span>
<span class="k">OPTIONS</span> <span class="p">(</span>
  <span class="n">path</span> <span class="ss">&quot;examples/src/main/resources/people.parquet&quot;</span>
<span class="p">)</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">parquetTable</span></code></pre></figure>

            </div>

        </div>

        <h3 id="partition-discovery">分区发现</h3>

        <p>在系统中，比如 Hive，表分区是一个很常见的优化途径。
            在一个分区表中 ，数据通常存储在不同的文件目录中，对每一个分区目录中的途径按照分区列的值进行编码。
            所有的文件 (including Text/CSV/JSON/ORC/Parquet)
            数据源现在可以自动地发现并且推断出分区的信息。
            例如，我们可以将之前使用的人口数据存储成下列目录结构的分区表，两个额外的列，<code>gender</code> 和 <code>country</code>  作为分区列 :
            </p>

        <figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>path
└── to
    └── table
        ├── gender=male
        │   ├── ...
        │   │
        │   ├── country=US
        │   │   └── data.parquet
        │   ├── country=CN
        │   │   └── data.parquet
        │   └── ...
        └── gender=female
            ├── ...
            │
            ├── country=US
            │   └── data.parquet
            ├── country=CN
            │   └── data.parquet
            └── ...</code></pre></figure>

        <p>向<code>SparkSession.read.parquet</code> 或
            <code>SparkSession.read.load</code>中传入<code>path/to/table</code>
            Spark SQL 将会自动地从路径中提取分区信息。现在返回的 DataFrame 模式变成 :
        </p>

        <figure class="highlight"><pre><code class="language-text" data-lang="text"><span></span>root
|-- name: string (nullable = true)
|-- age: long (nullable = true)
|-- gender: string (nullable = true)
|-- country: string (nullable = true)</code></pre></figure>

        <p>需要注意的是分区列的数据类型是自动推导出的。当前，支持数值数据类型以及 string 类型。
            有些时候用户可能不希望自动推导出分区列的数据类型。对于这些使用场景，自动类型推导功能可以通过
            <code>spark.sql.sources.partitionColumnTypeInference.enabled</code>,
            来配置，默认值是 <code>true</code>。当自动类型推导功能禁止，分区列的数据类型是 string。

        </p>

        <p>从 Spark 1.6.0 开始，分区发现只能发现在默认给定的路径下的分区。对于上面那个例子，如果用户向
            <code>SparkSession.read.parquet</code> 或 <code>SparkSession.read.load</code>传递
            <code>path/to/table/gender=male</code>
            将不会被当做分区列。如果用户需要指定发现的根目录，可以在数据源设置<code>basePath</code>
            比如，将<code>path/to/table/gender=male</code>作为数据的路径
            ,并且设置 <code>basePath</code>  为  <code>path/to/table/</code>，<code>gender</code> 将会作为一个分区列。

       </p>

        <h3 id="schema-merging">Schema Merging （Schema 合并）</h3>

        <p>类似 ProtocolBuffer，Avro，以及 Thrift，Parquet 也支持 schema 演变。
            用户可以从一个简单的 schema 开始，并且根据需要逐渐地向 schema 中添加更多的列。
            这样，用户最终可能会有多个不同但是具有相互兼容 schema 的 Parquet 文件。
            Parquet 数据源现在可以自动地发现这种情况，并且将所有这些文件的 schema 进行合并。</p>

        <p>由于模式合并是一项相对昂贵的操作，并且在大多数情况下不是必需的，因此我们默认从1.5.0开始关闭它。 您可以启用它</p>

        <ol>
            <li>在读取Parquet文件时将数据源选项<code>mergeSchema</code> 设置为
                <code>true</code>（如下面的示例所示），或</li>
            <li>将全局SQL选项<code>spark.sql.parquet.mergeSchema</code>设置为 <code>true</code>。</li>
        </ol>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="c1">// This is used to implicitly convert an RDD to a DataFrame.</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>

<span class="c1">// Create a simple DataFrame, store into a partition directory</span>
<span class="k">val</span> <span class="n">squaresDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span><span class="o">.</span><span class="n">makeRDD</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">)).</span><span class="n">toDF</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">,</span> <span class="s">&quot;square&quot;</span><span class="o">)</span>
<span class="n">squaresDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table/key=1&quot;</span><span class="o">)</span>

<span class="c1">// Create another DataFrame in a new partition directory,</span>
<span class="c1">// adding a new column and dropping an existing column</span>
<span class="k">val</span> <span class="n">cubesDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span><span class="o">.</span><span class="n">makeRDD</span><span class="o">(</span><span class="mi">6</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">)).</span><span class="n">toDF</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">,</span> <span class="s">&quot;cube&quot;</span><span class="o">)</span>
<span class="n">cubesDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table/key=2&quot;</span><span class="o">)</span>

<span class="c1">// Read the partitioned table</span>
<span class="k">val</span> <span class="n">mergedDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;mergeSchema&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">).</span><span class="n">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table&quot;</span><span class="o">)</span>
<span class="n">mergedDF</span><span class="o">.</span><span class="n">printSchema</span><span class="o">()</span>

<span class="c1">// The final schema consists of all 3 columns in the Parquet files together</span>
<span class="c1">// with the partitioning column appeared in the partition directory paths</span>
<span class="c1">// root</span>
<span class="c1">//  |-- value: int (nullable = true)</span>
<span class="c1">//  |-- square: int (nullable = true)</span>
<span class="c1">//  |-- cube: int (nullable = true)</span>
<span class="c1">//  |-- key: int (nullable = true)</span>
</pre></div>
                <div><small>在 Spark Repo中"examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">square</span><span class="o">;</span>

  <span class="c1">// Getters and setters...</span>

<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Cube</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">cube</span><span class="o">;</span>

  <span class="c1">// Getters and setters...</span>

<span class="o">}</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Square</span><span class="o">&gt;</span> <span class="n">squares</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="o">;</span> <span class="n">value</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">Square</span> <span class="n">square</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Square</span><span class="o">();</span>
  <span class="n">square</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
  <span class="n">square</span><span class="o">.</span><span class="na">setSquare</span><span class="o">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">value</span><span class="o">);</span>
  <span class="n">squares</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">square</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Create a simple DataFrame, store into a partition directory</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">squaresDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataFrame</span><span class="o">(</span><span class="n">squares</span><span class="o">,</span> <span class="n">Square</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">squaresDF</span><span class="o">.</span><span class="na">write</span><span class="o">().</span><span class="na">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table/key=1&quot;</span><span class="o">);</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">Cube</span><span class="o">&gt;</span> <span class="n">cubes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">value</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">Cube</span> <span class="n">cube</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cube</span><span class="o">();</span>
  <span class="n">cube</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
  <span class="n">cube</span><span class="o">.</span><span class="na">setCube</span><span class="o">(</span><span class="n">value</span> <span class="o">*</span> <span class="n">value</span> <span class="o">*</span> <span class="n">value</span><span class="o">);</span>
  <span class="n">cubes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cube</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Create another DataFrame in a new partition directory,</span>
<span class="c1">// adding a new column and dropping an existing column</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">cubesDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataFrame</span><span class="o">(</span><span class="n">cubes</span><span class="o">,</span> <span class="n">Cube</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">cubesDF</span><span class="o">.</span><span class="na">write</span><span class="o">().</span><span class="na">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table/key=2&quot;</span><span class="o">);</span>

<span class="c1">// Read the partitioned table</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">mergedDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;mergeSchema&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="na">parquet</span><span class="o">(</span><span class="s">&quot;data/test_table&quot;</span><span class="o">);</span>
<span class="n">mergedDF</span><span class="o">.</span><span class="na">printSchema</span><span class="o">();</span>

<span class="c1">// The final schema consists of all 3 columns in the Parquet files together</span>
<span class="c1">// with the partitioning column appeared in the partition directory paths</span>
<span class="c1">// root</span>
<span class="c1">//  |-- value: int (nullable = true)</span>
<span class="c1">//  |-- square: int (nullable = true)</span>
<span class="c1">//  |-- cube: int (nullable = true)</span>
<span class="c1">//  |-- key: int (nullable = true)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">

                <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">Row</span>

<span class="c1"># spark is from the previous example.</span>
<span class="c1"># Create a simple DataFrame, stored into a partition directory</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>

<span class="n">squaresDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                                  <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Row</span><span class="p">(</span><span class="n">single</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">double</span><span class="o">=</span><span class="n">i</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
<span class="n">squaresDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;data/test_table/key=1&quot;</span><span class="p">)</span>

<span class="c1"># Create another DataFrame in a new partition directory,</span>
<span class="c1"># adding a new column and dropping an existing column</span>
<span class="n">cubesDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
                                <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Row</span><span class="p">(</span><span class="n">single</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">triple</span><span class="o">=</span><span class="n">i</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)))</span>
<span class="n">cubesDF</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;data/test_table/key=2&quot;</span><span class="p">)</span>

<span class="c1"># Read the partitioned table</span>
<span class="n">mergedDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;mergeSchema&quot;</span><span class="p">,</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="s2">&quot;data/test_table&quot;</span><span class="p">)</span>
<span class="n">mergedDF</span><span class="o">.</span><span class="n">printSchema</span><span class="p">()</span>

<span class="c1"># The final schema consists of all 3 columns in the Parquet files together</span>
<span class="c1"># with the partitioning column appeared in the partition directory paths.</span>
<span class="c1"># root</span>
<span class="c1">#  |-- double: long (nullable = true)</span>
<span class="c1">#  |-- single: long (nullable = true)</span>
<span class="c1">#  |-- triple: long (nullable = true)</span>
<span class="c1">#  |-- key: integer (nullable = true)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">

                <div class="highlight"><pre><span></span>df1 <span class="o">&lt;-</span> createDataFrame<span class="p">(</span><span class="kt">data.frame</span><span class="p">(</span>single<span class="o">=</span><span class="kt">c</span><span class="p">(</span><span class="m">12</span><span class="p">,</span> <span class="m">29</span><span class="p">),</span> <span class="kt">double</span><span class="o">=</span><span class="kt">c</span><span class="p">(</span><span class="m">19</span><span class="p">,</span> <span class="m">23</span><span class="p">)))</span>
df2 <span class="o">&lt;-</span> createDataFrame<span class="p">(</span><span class="kt">data.frame</span><span class="p">(</span><span class="kt">double</span><span class="o">=</span><span class="kt">c</span><span class="p">(</span><span class="m">19</span><span class="p">,</span> <span class="m">23</span><span class="p">),</span> triple<span class="o">=</span><span class="kt">c</span><span class="p">(</span><span class="m">23</span><span class="p">,</span> <span class="m">18</span><span class="p">)))</span>

<span class="c1"># Create a simple DataFrame, stored into a partition directory</span>
write.df<span class="p">(</span>df1<span class="p">,</span> <span class="s">&quot;data/test_table/key=1&quot;</span><span class="p">,</span> <span class="s">&quot;parquet&quot;</span><span class="p">,</span> <span class="s">&quot;overwrite&quot;</span><span class="p">)</span>

<span class="c1"># Create another DataFrame in a new partition directory,</span>
<span class="c1"># adding a new column and dropping an existing column</span>
write.df<span class="p">(</span>df2<span class="p">,</span> <span class="s">&quot;data/test_table/key=2&quot;</span><span class="p">,</span> <span class="s">&quot;parquet&quot;</span><span class="p">,</span> <span class="s">&quot;overwrite&quot;</span><span class="p">)</span>

<span class="c1"># Read the partitioned table</span>
df3 <span class="o">&lt;-</span> read.df<span class="p">(</span><span class="s">&quot;data/test_table&quot;</span><span class="p">,</span> <span class="s">&quot;parquet&quot;</span><span class="p">,</span> mergeSchema <span class="o">=</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
printSchema<span class="p">(</span>df3<span class="p">)</span>
<span class="c1"># The final schema consists of all 3 columns in the Parquet files together</span>
<span class="c1"># with the partitioning column appeared in the partition directory paths</span>
<span class="c1">## root</span>
<span class="c1">##  |-- single: double (nullable = true)</span>
<span class="c1">##  |-- double: double (nullable = true)</span>
<span class="c1">##  |-- triple: double (nullable = true)</span>
<span class="c1">##  |-- key: integer (nullable = true)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>

        </div>

        <h3 id="hive-metastore-parquet-table-conversion">Hive Metastore Parquet表转换</h3>

        <p>
            当从 Hive metastore 里读写 Parquet 表时，为了更好地提升新能 Spark SQL 会尝试用自己支持的 Parquet 替代 Hive SerDe。
            这个功能通过 <code>spark.sql.hive.convertMetastoreParquet</code> 选项来控制，默认是开启的。
        </p>

        <h4 id="hiveparquet-schema-reconciliation">Hive/Parquet Schema Reconciliation</h4>

        <p>从 Hive 和 Parquet 处理表 schema 过程的角度来看有两处关键的不同。</p>

        <ol>
            <li>Hive 对大小写不敏感，而 Parquet 不是。</li>
            <li>Hive 认为所有列都是 nullable 可为空的，在 Parquet 中为 nullability 是需要显示声明的。</li>
        </ol>

        <p>由于这些原因，当我们将 Hive metastore Parquet table 转换为Spark SQLtable 时必须使 Hive metastore schema 与 Parquet schema 相兼容。兼容规则如下 : </p>

        <ol>
            <li>
                <p>除了nullability，相同 schema 的字段的数据类型必须相同。要兼容的字段应该具有 Parquet 的数据类型，因此 nullability 是被推崇的</p>
            </li>
            <li>
                <p>reconciled schema 包含了这些 Hive metastore schema 里定义的字段。 </p>

                <ul>
                    <li>任何字段只出现在 Parquet schema 中会被 reconciled schema 排除。</li>
                    <li>任何字段只出现在 Hive metastore schema 中会被当做 nullable 字段来添加到 reconciled schema 中。</li>
                </ul>
            </li>
        </ol>

        <h4 id="metadata-refreshing">Metadata 刷新</h4>

        <p>为了提高性能 Spark SQL 缓存了 Parquet metadata。当 Hive metastore Parquet table 转换功能开启，这些转换后的元数据信息也会被缓存。如果这些表被 Hive 或者其他外部的工具更新，你需要手动刷新以确保元数据信息保持一致。</p>

        <div class="codetabs">

            <div data-lang="scala">

                <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// spark is an existing SparkSession</span>
<span class="n">spark</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">refreshTable</span><span class="o">(</span><span class="s">&quot;my_table&quot;</span><span class="o">)</span></code></pre></figure>

            </div>

            <div data-lang="java">

                <figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="c1">// spark is an existing SparkSession</span>
<span class="n">spark</span><span class="o">.</span><span class="na">catalog</span><span class="o">().</span><span class="na">refreshTable</span><span class="o">(</span><span class="s">&quot;my_table&quot;</span><span class="o">);</span></code></pre></figure>

            </div>

            <div data-lang="python">

                <figure class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="c1"># spark is an existing SparkSession</span>
<span class="n">spark</span><span class="o">.</span><span class="n">catalog</span><span class="o">.</span><span class="n">refreshTable</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">)</span></code></pre></figure>

            </div>

            <div data-lang="r">

                <figure class="highlight"><pre><code class="language-r" data-lang="r"><span></span>refreshTable<span class="p">(</span><span class="s">&quot;my_table&quot;</span><span class="p">)</span></code></pre></figure>

            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="n">REFRESH</span> <span class="k">TABLE</span> <span class="n">my_table</span><span class="p">;</span></code></pre></figure>

            </div>

        </div>

        <h3 id="configuration">配置</h3>

        <p>
            Parquet 的配置可以使用 <code>SparkSession</code> 的 <code>setConf</code> 来设置或者通过使用 SQL 运行
            <code>SET key=value</code> 命令。
        </p>

        <table class="table">
            <tr><th>Property Name</th><th>Default</th><th>Meaning</th></tr>
            <tr>
                <td><code>spark.sql.parquet.binaryAsString</code></td>
                <td>false</td>
                <td>
                    Some other Parquet-producing systems, in particular Impala, Hive, and older versions of Spark SQL, do
                    not differentiate between binary data and strings when writing out the Parquet schema. This
                    flag tells Spark SQL to interpret binary data as a string to provide compatibility with these systems.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.parquet.int96AsTimestamp</code></td>
                <td>true</td>
                <td>
                    Some Parquet-producing systems, in particular Impala and Hive, store Timestamp into INT96. This
                    flag tells Spark SQL to interpret INT96 data as a timestamp to provide compatibility with these systems.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.parquet.compression.codec</code></td>
                <td>snappy</td>
                <td>
                    Sets the compression codec used when writing Parquet files. If either `compression` or
                    `parquet.compression` is specified in the table-specific options/properties, the precedence would be
                    `compression`, `parquet.compression`, `spark.sql.parquet.compression.codec`. Acceptable values include:
                    none, uncompressed, snappy, gzip, lzo.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.parquet.filterPushdown</code></td>
                <td>true</td>
                <td>Enables Parquet filter push-down optimization when set to true.</td>
            </tr>
            <tr>
                <td><code>spark.sql.hive.convertMetastoreParquet</code></td>
                <td>true</td>
                <td>
                    When set to false, Spark SQL will use the Hive SerDe for parquet tables instead of the built in
                    support.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.parquet.mergeSchema</code></td>
                <td>false</td>
                <td>
                    <p>
                        When true, the Parquet data source merges schemas collected from all data files, otherwise the
                        schema is picked from the summary file or a random data file if no summary file is available.
                    </p>
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.optimizer.metadataOnly</code></td>
                <td>true</td>
                <td>
                    <p>
                        When true, enable the metadata-only query optimization that use the table's metadata to
                        produce the partition columns instead of table scans. It applies when all the columns scanned
                        are partition columns and the query has an aggregate operator that satisfies distinct
                        semantics.
                    </p>
                </td>
            </tr>
        </table>

        <h2 id="orc-files">ORC Files</h2>

        <p>

            从Spark 2.3开始，Spark支持带有ORC文件的新ORC文件格式的矢量化ORC阅读器。
            为此，新添加了以下配置。 当spark.sql.orc.impl设置为<code>native</code>并且<code>spark.sql.orc.enableVectorizedReader</code>设置为true时，
            矢量化读取器用于本机ORC表（例如，使用<code>USING ORC</code>子句创建的表）。
            对于Hive ORC serde表（例如，使用<code>USING HIVE OPTIONS (fileFormat 'ORC')</code>子句创建的表），
            当<code>spark.sql.hive.convertMetastoreOrc</code>也设置为<code>true</code>时，使用矢量化阅读器。

        </p>

        <table class="table">
            <tr><th><b>Property Name</b></th><th><b>Default</b></th><th><b>Meaning</b></th></tr>
            <tr>
                <td><code>spark.sql.orc.impl</code></td>
                <td><code>hive</code></td>
                <td>The name of ORC implementation. It can be one of <code>native</code> and <code>hive</code>. <code>native</code> means the native ORC support that is built on Apache ORC 1.4.1. `hive` means the ORC library in Hive 1.2.1.</td>
            </tr>
            <tr>
                <td><code>spark.sql.orc.enableVectorizedReader</code></td>
                <td><code>true</code></td>
                <td>Enables vectorized orc decoding in <code>native</code> implementation. If <code>false</code>, a new non-vectorized ORC reader is used in <code>native</code> implementation. For <code>hive</code> implementation, this is ignored.</td>
            </tr>
        </table>

        <h2 id="json-datasets">JSON Datasets</h2>
        <div class="codetabs">

            <div data-lang="scala">
                <p>
                    Spark SQL 可以自动的推断出 JSON 数据集的 schema 并且将它作为 DataFrame 进行加载。
                </p>

                <p>注意作为<em>json file</em> 提供的文件不是一个典型的 JSON 文件
                    每一行必须包含一个分开的独立的有效 JSON 对象。 有关更多信息，请参阅
                    <a href="http://jsonlines.org/">JSON Lines text format, also called newline-delimited JSON</a>.</p>

                <p>

                    对于常规多行JSON文件，请将<code>multiLine</code>选项设置为<code>true</code>。
                </p>

                <div class="highlight"><pre><span></span><span class="c1">// Primitive types (Int, String, etc) and Product types (case classes) encoders are</span>
<span class="c1">// supported by importing this when creating a Dataset.</span>
<span class="k">import</span> <span class="nn">spark.implicits._</span>

<span class="c1">// A JSON dataset is pointed to by path.</span>
<span class="c1">// The path can be either a single text file or a directory storing text files</span>
<span class="k">val</span> <span class="n">path</span> <span class="k">=</span> <span class="s">&quot;examples/src/main/resources/people.json&quot;</span>
<span class="k">val</span> <span class="n">peopleDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>

<span class="c1">// The inferred schema can be visualized using the printSchema() method</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">printSchema</span><span class="o">()</span>
<span class="c1">// root</span>
<span class="c1">//  |-- age: long (nullable = true)</span>
<span class="c1">//  |-- name: string (nullable = true)</span>

<span class="c1">// Creates a temporary view using the DataFrame</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">)</span>

<span class="c1">// SQL statements can be run by using the sql methods provided by spark</span>
<span class="k">val</span> <span class="n">teenagerNamesDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM people WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">)</span>
<span class="n">teenagerNamesDF</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +------+</span>
<span class="c1">// |  name|</span>
<span class="c1">// +------+</span>
<span class="c1">// |Justin|</span>
<span class="c1">// +------+</span>

<span class="c1">// Alternatively, a DataFrame can be created for a JSON dataset represented by</span>
<span class="c1">// a Dataset[String] storing one JSON object per string</span>
<span class="k">val</span> <span class="n">otherPeopleDataset</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataset</span><span class="o">(</span>
  <span class="s">&quot;&quot;&quot;{&quot;name&quot;:&quot;Yin&quot;,&quot;address&quot;:{&quot;city&quot;:&quot;Columbus&quot;,&quot;state&quot;:&quot;Ohio&quot;}}&quot;&quot;&quot;</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
<span class="k">val</span> <span class="n">otherPeople</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="o">(</span><span class="n">otherPeopleDataset</span><span class="o">)</span>
<span class="n">otherPeople</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +---------------+----+</span>
<span class="c1">// |        address|name|</span>
<span class="c1">// +---------------+----+</span>
<span class="c1">// |[Columbus,Ohio]| Yin|</span>
<span class="c1">// +---------------+----+</span>
</pre></div>
                <div><small>在 Spark Repo中 "examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <p>Spark SQL can automatically infer the schema of a JSON dataset and load it as a <code>Dataset&lt;Row&gt;</code>.
                    This conversion can be done using <code>SparkSession.read().json()</code> on either a <code>Dataset&lt;String&gt;</code>,
                    or a JSON file.</p>

                <p>Note that the file that is offered as <em>a json file</em> is not a typical JSON file. Each
                    line must contain a separate, self-contained valid JSON object. For more information, please see
                    <a href="http://jsonlines.org/">JSON Lines text format, also called newline-delimited JSON</a>.</p>

                <p>For a regular multi-line JSON file, set the <code>multiLine</code> option to <code>true</code>.</p>

                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>

<span class="c1">// A JSON dataset is pointed to by path.</span>
<span class="c1">// The path can be either a single text file or a directory storing text files</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="s">&quot;examples/src/main/resources/people.json&quot;</span><span class="o">);</span>

<span class="c1">// The inferred schema can be visualized using the printSchema() method</span>
<span class="n">people</span><span class="o">.</span><span class="na">printSchema</span><span class="o">();</span>
<span class="c1">// root</span>
<span class="c1">//  |-- age: long (nullable = true)</span>
<span class="c1">//  |-- name: string (nullable = true)</span>

<span class="c1">// Creates a temporary view using the DataFrame</span>
<span class="n">people</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;people&quot;</span><span class="o">);</span>

<span class="c1">// SQL statements can be run by using the sql methods provided by spark</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">namesDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT name FROM people WHERE age BETWEEN 13 AND 19&quot;</span><span class="o">);</span>
<span class="n">namesDF</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +------+</span>
<span class="c1">// |  name|</span>
<span class="c1">// +------+</span>
<span class="c1">// |Justin|</span>
<span class="c1">// +------+</span>

<span class="c1">// Alternatively, a DataFrame can be created for a JSON dataset represented by</span>
<span class="c1">// a Dataset&lt;String&gt; storing one JSON object per string.</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="s">&quot;{\&quot;name\&quot;:\&quot;Yin\&quot;,\&quot;address\&quot;:{\&quot;city\&quot;:\&quot;Columbus\&quot;,\&quot;state\&quot;:\&quot;Ohio\&quot;}}&quot;</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">anotherPeopleDataset</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataset</span><span class="o">(</span><span class="n">jsonData</span><span class="o">,</span> <span class="n">Encoders</span><span class="o">.</span><span class="na">STRING</span><span class="o">());</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">anotherPeople</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">json</span><span class="o">(</span><span class="n">anotherPeopleDataset</span><span class="o">);</span>
<span class="n">anotherPeople</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +---------------+----+</span>
<span class="c1">// |        address|name|</span>
<span class="c1">// +---------------+----+</span>
<span class="c1">// |[Columbus,Ohio]| Yin|</span>
<span class="c1">// +---------------+----+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <p>Spark SQL can automatically infer the schema of a JSON dataset and load it as a DataFrame.
                    This conversion can be done using <code>SparkSession.read.json</code> on a JSON file.</p>

                <p>Note that the file that is offered as <em>a json file</em> is not a typical JSON file. Each
                    line must contain a separate, self-contained valid JSON object. For more information, please see
                    <a href="http://jsonlines.org/">JSON Lines text format, also called newline-delimited JSON</a>.</p>

                <p>For a regular multi-line JSON file, set the <code>multiLine</code> parameter to <code>True</code>.</p>

                <div class="highlight"><pre><span></span><span class="c1"># spark is from the previous example.</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span>

<span class="c1"># A JSON dataset is pointed to by path.</span>
<span class="c1"># The path can be either a single text file or a directory storing text files</span>
<span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;examples/src/main/resources/people.json&quot;</span>
<span class="n">peopleDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="c1"># The inferred schema can be visualized using the printSchema() method</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">printSchema</span><span class="p">()</span>
<span class="c1"># root</span>
<span class="c1">#  |-- age: long (nullable = true)</span>
<span class="c1">#  |-- name: string (nullable = true)</span>

<span class="c1"># Creates a temporary view using the DataFrame</span>
<span class="n">peopleDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;people&quot;</span><span class="p">)</span>

<span class="c1"># SQL statements can be run by using the sql methods provided by spark</span>
<span class="n">teenagerNamesDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT name FROM people WHERE age BETWEEN 13 AND 19&quot;</span><span class="p">)</span>
<span class="n">teenagerNamesDF</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +------+</span>
<span class="c1"># |  name|</span>
<span class="c1"># +------+</span>
<span class="c1"># |Justin|</span>
<span class="c1"># +------+</span>

<span class="c1"># Alternatively, a DataFrame can be created for a JSON dataset represented by</span>
<span class="c1"># an RDD[String] storing one JSON object per string</span>
<span class="n">jsonStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;{&quot;name&quot;:&quot;Yin&quot;,&quot;address&quot;:{&quot;city&quot;:&quot;Columbus&quot;,&quot;state&quot;:&quot;Ohio&quot;}}&#39;</span><span class="p">]</span>
<span class="n">otherPeopleRDD</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">jsonStrings</span><span class="p">)</span>
<span class="n">otherPeople</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="n">otherPeopleRDD</span><span class="p">)</span>
<span class="n">otherPeople</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +---------------+----+</span>
<span class="c1"># |        address|name|</span>
<span class="c1"># +---------------+----+</span>
<span class="c1"># |[Columbus,Ohio]| Yin|</span>
<span class="c1"># +---------------+----+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <p>Spark SQL can automatically infer the schema of a JSON dataset and load it as a DataFrame. using
                    the <code>read.json()</code> function, which loads data from a directory of JSON files where each line of the
                    files is a JSON object.</p>

                <p>Note that the file that is offered as <em>a json file</em> is not a typical JSON file. Each
                    line must contain a separate, self-contained valid JSON object. For more information, please see
                    <a href="http://jsonlines.org/">JSON Lines text format, also called newline-delimited JSON</a>.</p>

                <p>For a regular multi-line JSON file, set a named parameter <code>multiLine</code> to <code>TRUE</code>.</p>

                <div class="highlight"><pre><span></span><span class="c1"># A JSON dataset is pointed to by path.</span>
<span class="c1"># The path can be either a single text file or a directory storing text files.</span>
path <span class="o">&lt;-</span> <span class="s">&quot;examples/src/main/resources/people.json&quot;</span>
<span class="c1"># Create a DataFrame from the file(s) pointed to by path</span>
people <span class="o">&lt;-</span> read.json<span class="p">(</span>path<span class="p">)</span>

<span class="c1"># The inferred schema can be visualized using the printSchema() method.</span>
printSchema<span class="p">(</span>people<span class="p">)</span>
<span class="c1">## root</span>
<span class="c1">##  |-- age: long (nullable = true)</span>
<span class="c1">##  |-- name: string (nullable = true)</span>

<span class="c1"># Register this DataFrame as a table.</span>
createOrReplaceTempView<span class="p">(</span>people<span class="p">,</span> <span class="s">&quot;people&quot;</span><span class="p">)</span>

<span class="c1"># SQL statements can be run by using the sql methods.</span>
teenagers <span class="o">&lt;-</span> sql<span class="p">(</span><span class="s">&quot;SELECT name FROM people WHERE age &gt;= 13 AND age &lt;= 19&quot;</span><span class="p">)</span>
<span class="kp">head</span><span class="p">(</span>teenagers<span class="p">)</span>
<span class="c1">##     name</span>
<span class="c1">## 1 Justin</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TEMPORARY</span> <span class="k">VIEW</span> <span class="n">jsonTable</span>
<span class="k">USING</span> <span class="n">org</span><span class="p">.</span><span class="n">apache</span><span class="p">.</span><span class="n">spark</span><span class="p">.</span><span class="k">sql</span><span class="p">.</span><span class="n">json</span>
<span class="k">OPTIONS</span> <span class="p">(</span>
  <span class="n">path</span> <span class="ss">&quot;examples/src/main/resources/people.json&quot;</span>
<span class="p">)</span>

<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">jsonTable</span></code></pre></figure>

            </div>

        </div>

        <h2 id="hive-tables">Hive 表</h2>

        <p>Spark SQL 还支持在 <a href="http://hive.apache.org/">Apache Hive</a> 中读写数据。
            然而，由于 Hive 依赖项太多，这些依赖没有包含在默认的 Spark 发行版本中。
            如果在 classpath 上配置了 Hive 依赖，那么 Spark 会自动加载它们。
            注意，Hive 依赖也必须放到所有的 worker 节点上，因为如果要访问 Hive 中的数据它们需要访问 Hive 序列化和反序列化库（SerDes)。</p>

        <p>Hive 配置是通过将<code>hive-site.xml</code>, <code>core-site.xml</code> (用于HDFS 配置),
            和 <code>hdfs-site.xml</code> (用于HDFS 配置) 文件放置在<code>conf/</code>目录下来完成的。</p>

        <p>如果要使用 Hive, 你必须要实例化一个支持 Hive 的 <code>SparkSession</code>，
            包括连接到一个持久化的 Hive metastore, 支持 Hive 序列化反序列化库以及 Hive 用户自定义函数。
            即使用户没有安装部署 Hive 也仍然可以启用 Hive 支持。 如果没有在 <code>hive-site.xml</code>文件中配置,
            Spark 应用程序启动之后，上下文会自动在当前目录下创建一个<code>metastore_db</code> 目录并创建一个由
            <code>spark.sql.warehouse.dir</code>,  配置的、默认值是当前目录下的
            <code>spark-warehouse</code> 目录的目录。
            请注意 : 从 Spark 2.0.0 版本开始，<code>hive-site.xml</code> 中的
            <code>hive.metastore.warehouse.dir</code> 属性就过时了。
            你可以使用<code>spark.sql.warehouse.dir</code> 指定仓库中数据库的默认存储位置。你可能还需要给启动 Spark 应用程序的用户赋予写权限。</p>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.File</span>

<span class="k">import</span> <span class="nn">org.apache.spark.sql.</span><span class="o">{</span><span class="nc">Row</span><span class="o">,</span> <span class="nc">SaveMode</span><span class="o">,</span> <span class="nc">SparkSession</span><span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Record</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// warehouseLocation points to the default location for managed databases and tables</span>
<span class="k">val</span> <span class="n">warehouseLocation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&quot;spark-warehouse&quot;</span><span class="o">).</span><span class="n">getAbsolutePath</span>

<span class="k">val</span> <span class="n">spark</span> <span class="k">=</span> <span class="nc">SparkSession</span>
  <span class="o">.</span><span class="n">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="n">appName</span><span class="o">(</span><span class="s">&quot;Spark Hive Example&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">config</span><span class="o">(</span><span class="s">&quot;spark.sql.warehouse.dir&quot;</span><span class="o">,</span> <span class="n">warehouseLocation</span><span class="o">)</span>
  <span class="o">.</span><span class="n">enableHiveSupport</span><span class="o">()</span>
  <span class="o">.</span><span class="n">getOrCreate</span><span class="o">()</span>

<span class="k">import</span> <span class="nn">spark.implicits._</span>
<span class="k">import</span> <span class="nn">spark.sql</span>

<span class="n">sql</span><span class="o">(</span><span class="s">&quot;CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive&quot;</span><span class="o">)</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;LOAD DATA LOCAL INPATH &#39;examples/src/main/resources/kv1.txt&#39; INTO TABLE src&quot;</span><span class="o">)</span>

<span class="c1">// Queries are expressed in HiveQL</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM src&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +---+-------+</span>
<span class="c1">// |key|  value|</span>
<span class="c1">// +---+-------+</span>
<span class="c1">// |238|val_238|</span>
<span class="c1">// | 86| val_86|</span>
<span class="c1">// |311|val_311|</span>
<span class="c1">// ...</span>

<span class="c1">// Aggregation queries are also supported.</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT COUNT(*) FROM src&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +--------+</span>
<span class="c1">// |count(1)|</span>
<span class="c1">// +--------+</span>
<span class="c1">// |    500 |</span>
<span class="c1">// +--------+</span>

<span class="c1">// The results of SQL queries are themselves DataFrames and support all normal functions.</span>
<span class="k">val</span> <span class="n">sqlDF</span> <span class="k">=</span> <span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT key, value FROM src WHERE key &lt; 10 ORDER BY key&quot;</span><span class="o">)</span>

<span class="c1">// The items in DataFrames are of type Row, which allows you to access each column by ordinal.</span>
<span class="k">val</span> <span class="n">stringsDS</span> <span class="k">=</span> <span class="n">sqlDF</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Row</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&quot;Key: </span><span class="si">$key</span><span class="s">, Value: </span><span class="si">$value</span><span class="s">&quot;</span>
<span class="o">}</span>
<span class="n">stringsDS</span><span class="o">.</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +--------------------+</span>
<span class="c1">// |               value|</span>
<span class="c1">// +--------------------+</span>
<span class="c1">// |Key: 0, Value: val_0|</span>
<span class="c1">// |Key: 0, Value: val_0|</span>
<span class="c1">// |Key: 0, Value: val_0|</span>
<span class="c1">// ...</span>

<span class="c1">// You can also use DataFrames to create temporary views within a SparkSession.</span>
<span class="k">val</span> <span class="n">recordsDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="o">((</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">100</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Record</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="s">s&quot;val_</span><span class="si">$i</span><span class="s">&quot;</span><span class="o">)))</span>
<span class="n">recordsDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;records&quot;</span><span class="o">)</span>

<span class="c1">// Queries can then join DataFrame data with data stored in Hive.</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM records r JOIN src s ON r.key = s.key&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +---+------+---+------+</span>
<span class="c1">// |key| value|key| value|</span>
<span class="c1">// +---+------+---+------+</span>
<span class="c1">// |  2| val_2|  2| val_2|</span>
<span class="c1">// |  4| val_4|  4| val_4|</span>
<span class="c1">// |  5| val_5|  5| val_5|</span>
<span class="c1">// ...</span>

<span class="c1">// Create a Hive managed Parquet table, with HQL syntax instead of the Spark SQL native syntax</span>
<span class="c1">// `USING hive`</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;CREATE TABLE hive_records(key int, value string) STORED AS PARQUET&quot;</span><span class="o">)</span>
<span class="c1">// Save DataFrame to the Hive managed table</span>
<span class="k">val</span> <span class="n">df</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">table</span><span class="o">(</span><span class="s">&quot;src&quot;</span><span class="o">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">mode</span><span class="o">(</span><span class="nc">SaveMode</span><span class="o">.</span><span class="nc">Overwrite</span><span class="o">).</span><span class="n">saveAsTable</span><span class="o">(</span><span class="s">&quot;hive_records&quot;</span><span class="o">)</span>
<span class="c1">// After insertion, the Hive managed table has data now</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM hive_records&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +---+-------+</span>
<span class="c1">// |key|  value|</span>
<span class="c1">// +---+-------+</span>
<span class="c1">// |238|val_238|</span>
<span class="c1">// | 86| val_86|</span>
<span class="c1">// |311|val_311|</span>
<span class="c1">// ...</span>

<span class="c1">// Prepare a Parquet data directory</span>
<span class="k">val</span> <span class="n">dataDir</span> <span class="k">=</span> <span class="s">&quot;/tmp/parquet_data&quot;</span>
<span class="n">spark</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="n">write</span><span class="o">.</span><span class="n">parquet</span><span class="o">(</span><span class="n">dataDir</span><span class="o">)</span>
<span class="c1">// Create a Hive external Parquet table</span>
<span class="n">sql</span><span class="o">(</span><span class="s">s&quot;CREATE EXTERNAL TABLE hive_ints(key int) STORED AS PARQUET LOCATION &#39;</span><span class="si">$dataDir</span><span class="s">&#39;&quot;</span><span class="o">)</span>
<span class="c1">// The Hive external table should already have data</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM hive_ints&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +---+</span>
<span class="c1">// |key|</span>
<span class="c1">// +---+</span>
<span class="c1">// |  0|</span>
<span class="c1">// |  1|</span>
<span class="c1">// |  2|</span>
<span class="c1">// ...</span>

<span class="c1">// Turn on flag for Hive Dynamic Partitioning</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sqlContext</span><span class="o">.</span><span class="n">setConf</span><span class="o">(</span><span class="s">&quot;hive.exec.dynamic.partition&quot;</span><span class="o">,</span> <span class="s">&quot;true&quot;</span><span class="o">)</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sqlContext</span><span class="o">.</span><span class="n">setConf</span><span class="o">(</span><span class="s">&quot;hive.exec.dynamic.partition.mode&quot;</span><span class="o">,</span> <span class="s">&quot;nonstrict&quot;</span><span class="o">)</span>
<span class="c1">// Create a Hive partitioned table using DataFrame API</span>
<span class="n">df</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">partitionBy</span><span class="o">(</span><span class="s">&quot;key&quot;</span><span class="o">).</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;hive&quot;</span><span class="o">).</span><span class="n">saveAsTable</span><span class="o">(</span><span class="s">&quot;hive_part_tbl&quot;</span><span class="o">)</span>
<span class="c1">// Partitioned column `key` will be moved to the end of the schema.</span>
<span class="n">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM hive_part_tbl&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span>
<span class="c1">// +-------+---+</span>
<span class="c1">// |  value|key|</span>
<span class="c1">// +-------+---+</span>
<span class="c1">// |val_238|238|</span>
<span class="c1">// | val_86| 86|</span>
<span class="c1">// |val_311|311|</span>
<span class="c1">// ...</span>

<span class="n">spark</span><span class="o">.</span><span class="n">stop</span><span class="o">()</span>
</pre></div>
                <div><small>在 Spark Repo 中"examples/src/main/scala/org/apache/spark/examples/sql/hive/SparkHiveExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.apache.spark.api.java.function.MapFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Dataset</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Encoders</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.Row</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Record</span> <span class="kd">implements</span> <span class="n">Serializable</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">key</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">String</span> <span class="n">value</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// warehouseLocation points to the default location for managed databases and tables</span>
<span class="n">String</span> <span class="n">warehouseLocation</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&quot;spark-warehouse&quot;</span><span class="o">).</span><span class="na">getAbsolutePath</span><span class="o">();</span>
<span class="n">SparkSession</span> <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span>
  <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
  <span class="o">.</span><span class="na">appName</span><span class="o">(</span><span class="s">&quot;Java Spark Hive Example&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">config</span><span class="o">(</span><span class="s">&quot;spark.sql.warehouse.dir&quot;</span><span class="o">,</span> <span class="n">warehouseLocation</span><span class="o">)</span>
  <span class="o">.</span><span class="na">enableHiveSupport</span><span class="o">()</span>
  <span class="o">.</span><span class="na">getOrCreate</span><span class="o">();</span>

<span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive&quot;</span><span class="o">);</span>
<span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;LOAD DATA LOCAL INPATH &#39;examples/src/main/resources/kv1.txt&#39; INTO TABLE src&quot;</span><span class="o">);</span>

<span class="c1">// Queries are expressed in HiveQL</span>
<span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM src&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +---+-------+</span>
<span class="c1">// |key|  value|</span>
<span class="c1">// +---+-------+</span>
<span class="c1">// |238|val_238|</span>
<span class="c1">// | 86| val_86|</span>
<span class="c1">// |311|val_311|</span>
<span class="c1">// ...</span>

<span class="c1">// Aggregation queries are also supported.</span>
<span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT COUNT(*) FROM src&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +--------+</span>
<span class="c1">// |count(1)|</span>
<span class="c1">// +--------+</span>
<span class="c1">// |    500 |</span>
<span class="c1">// +--------+</span>

<span class="c1">// The results of SQL queries are themselves DataFrames and support all normal functions.</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">sqlDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT key, value FROM src WHERE key &lt; 10 ORDER BY key&quot;</span><span class="o">);</span>

<span class="c1">// The items in DataFrames are of type Row, which lets you to access each column by ordinal.</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stringsDS</span> <span class="o">=</span> <span class="n">sqlDF</span><span class="o">.</span><span class="na">map</span><span class="o">(</span>
    <span class="o">(</span><span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;)</span> <span class="n">row</span> <span class="o">-&gt;</span> <span class="s">&quot;Key: &quot;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;, Value: &quot;</span> <span class="o">+</span> <span class="n">row</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>
    <span class="n">Encoders</span><span class="o">.</span><span class="na">STRING</span><span class="o">());</span>
<span class="n">stringsDS</span><span class="o">.</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +--------------------+</span>
<span class="c1">// |               value|</span>
<span class="c1">// +--------------------+</span>
<span class="c1">// |Key: 0, Value: val_0|</span>
<span class="c1">// |Key: 0, Value: val_0|</span>
<span class="c1">// |Key: 0, Value: val_0|</span>
<span class="c1">// ...</span>

<span class="c1">// You can also use DataFrames to create temporary views within a SparkSession.</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Record</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">key</span><span class="o">++)</span> <span class="o">{</span>
  <span class="n">Record</span> <span class="n">record</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Record</span><span class="o">();</span>
  <span class="n">record</span><span class="o">.</span><span class="na">setKey</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
  <span class="n">record</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="s">&quot;val_&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
  <span class="n">records</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">recordsDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">createDataFrame</span><span class="o">(</span><span class="n">records</span><span class="o">,</span> <span class="n">Record</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">recordsDF</span><span class="o">.</span><span class="na">createOrReplaceTempView</span><span class="o">(</span><span class="s">&quot;records&quot;</span><span class="o">);</span>

<span class="c1">// Queries can then join DataFrames data with data stored in Hive.</span>
<span class="n">spark</span><span class="o">.</span><span class="na">sql</span><span class="o">(</span><span class="s">&quot;SELECT * FROM records r JOIN src s ON r.key = s.key&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
<span class="c1">// +---+------+---+------+</span>
<span class="c1">// |key| value|key| value|</span>
<span class="c1">// +---+------+---+------+</span>
<span class="c1">// |  2| val_2|  2| val_2|</span>
<span class="c1">// |  2| val_2|  2| val_2|</span>
<span class="c1">// |  4| val_4|  4| val_4|</span>
<span class="c1">// ...</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/hive/JavaSparkHiveExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">expanduser</span><span class="p">,</span> <span class="n">join</span><span class="p">,</span> <span class="n">abspath</span>

<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">Row</span>

<span class="c1"># warehouse_location points to the default location for managed databases and tables</span>
<span class="n">warehouse_location</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;spark-warehouse&#39;</span><span class="p">)</span>

<span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span> \
    <span class="o">.</span><span class="n">builder</span> \
    <span class="o">.</span><span class="n">appName</span><span class="p">(</span><span class="s2">&quot;Python Spark SQL Hive integration example&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="s2">&quot;spark.sql.warehouse.dir&quot;</span><span class="p">,</span> <span class="n">warehouse_location</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">enableHiveSupport</span><span class="p">()</span> \
    <span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>

<span class="c1"># spark is an existing SparkSession</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive&quot;</span><span class="p">)</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;LOAD DATA LOCAL INPATH &#39;examples/src/main/resources/kv1.txt&#39; INTO TABLE src&quot;</span><span class="p">)</span>

<span class="c1"># Queries are expressed in HiveQL</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +---+-------+</span>
<span class="c1"># |key|  value|</span>
<span class="c1"># +---+-------+</span>
<span class="c1"># |238|val_238|</span>
<span class="c1"># | 86| val_86|</span>
<span class="c1"># |311|val_311|</span>
<span class="c1"># ...</span>

<span class="c1"># Aggregation queries are also supported.</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT COUNT(*) FROM src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +--------+</span>
<span class="c1"># |count(1)|</span>
<span class="c1"># +--------+</span>
<span class="c1"># |    500 |</span>
<span class="c1"># +--------+</span>

<span class="c1"># The results of SQL queries are themselves DataFrames and support all normal functions.</span>
<span class="n">sqlDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT key, value FROM src WHERE key &lt; 10 ORDER BY key&quot;</span><span class="p">)</span>

<span class="c1"># The items in DataFrames are of type Row, which allows you to access each column by ordinal.</span>
<span class="n">stringsDS</span> <span class="o">=</span> <span class="n">sqlDF</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s2">&quot;Key: </span><span class="si">%d</span><span class="s2">, Value: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">stringsDS</span><span class="o">.</span><span class="n">collect</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
<span class="c1"># Key: 0, Value: val_0</span>
<span class="c1"># Key: 0, Value: val_0</span>
<span class="c1"># Key: 0, Value: val_0</span>
<span class="c1"># ...</span>

<span class="c1"># You can also use DataFrames to create temporary views within a SparkSession.</span>
<span class="n">Record</span> <span class="o">=</span> <span class="n">Row</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
<span class="n">recordsDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">([</span><span class="n">Record</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;val_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">)])</span>
<span class="n">recordsDF</span><span class="o">.</span><span class="n">createOrReplaceTempView</span><span class="p">(</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>

<span class="c1"># Queries can then join DataFrame data with data stored in Hive.</span>
<span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM records r JOIN src s ON r.key = s.key&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +---+------+---+------+</span>
<span class="c1"># |key| value|key| value|</span>
<span class="c1"># +---+------+---+------+</span>
<span class="c1"># |  2| val_2|  2| val_2|</span>
<span class="c1"># |  4| val_4|  4| val_4|</span>
<span class="c1"># |  5| val_5|  5| val_5|</span>
<span class="c1"># ...</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/hive.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">

                <p>When working with Hive one must instantiate <code>SparkSession</code> with Hive support. This
                    adds support for finding tables in the MetaStore and writing queries using HiveQL.</p>

                <div class="highlight"><pre><span></span><span class="c1"># enableHiveSupport defaults to TRUE</span>
sparkR.session<span class="p">(</span>enableHiveSupport <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
sql<span class="p">(</span><span class="s">&quot;CREATE TABLE IF NOT EXISTS src (key INT, value STRING) USING hive&quot;</span><span class="p">)</span>
sql<span class="p">(</span><span class="s">&quot;LOAD DATA LOCAL INPATH &#39;examples/src/main/resources/kv1.txt&#39; INTO TABLE src&quot;</span><span class="p">)</span>

<span class="c1"># Queries can be expressed in HiveQL.</span>
results <span class="o">&lt;-</span> collect<span class="p">(</span>sql<span class="p">(</span><span class="s">&quot;FROM src SELECT key, value&quot;</span><span class="p">))</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>

            </div>
        </div>

        <h3 id="specifying-storage-format-for-hive-tables">指定Hive表的存储格式</h3>

        <p>创建Hive表时，需要定义此表应如何从/向文件系统读取/写入数据，即“输入格式”和“输出格式”。
            您还需要定义此表如何将数据反序列化为行，或将行序列化为数据，即“serde”。
            以下选项可用于指定存储格式(&#8220;serde&#8221;, &#8220;input format&#8221;, &#8220;output format&#8221;), 例如：
            <code>CREATE TABLE src(id int) USING hive OPTIONS(fileFormat 'parquet')</code>.
            默认情况下，我们将表文件作为纯文本读取。
            请注意，创建表不支持Hive存储处理程序，您可以使用Hive端的存储处理程序创建表，并使用Spark SQL读取它。</p>

        <table class="table">
            <tr><th>Property Name</th><th>Meaning</th></tr>
            <tr>
                <td><code>fileFormat</code></td>
                <td>
                    A fileFormat is kind of a package of storage format specifications, including "serde", "input format" and
                    "output format". Currently we support 6 fileFormats: 'sequencefile', 'rcfile', 'orc', 'parquet', 'textfile' and 'avro'.
                </td>
            </tr>

            <tr>
                <td><code>inputFormat, outputFormat</code></td>
                <td>
                    These 2 options specify the name of a corresponding `InputFormat` and `OutputFormat` class as a string literal,
                    e.g. `org.apache.hadoop.hive.ql.io.orc.OrcInputFormat`. These 2 options must be appeared in pair, and you can not
                    specify them if you already specified the `fileFormat` option.
                </td>
            </tr>

            <tr>
                <td><code>serde</code></td>
                <td>
                    This option specifies the name of a serde class. When the `fileFormat` option is specified, do not specify this option
                    if the given `fileFormat` already include the information of serde. Currently "sequencefile", "textfile" and "rcfile"
                    don't include the serde information and you can use this option with these 3 fileFormats.
                </td>
            </tr>

            <tr>
                <td><code>fieldDelim, escapeDelim, collectionDelim, mapkeyDelim, lineDelim</code></td>
                <td>
                    These options can only be used with "textfile" fileFormat. They define how to read delimited files into rows.
                </td>
            </tr>
        </table>

        <p>使用<code>OPTIONS</code> 定义的所有其他属性将被视为Hive serde属性。</p>

        <h3 id="interacting-with-different-versions-of-hive-metastore">与不同版本的 Hive Metastore 交互</h3>

        <p>Spark SQL 对 Hive 最重要的一个支持就是可以和 Hive metastore 进行交互，这使得 Spark SQL 可以访问 Hive 表的元数据。从 Spark 1.4.0 版本开始，通过使用下面描述的配置，Spark SQL 一个简单的二进制编译版本可以用来查询不同版本的 Hive metastore。注意，不管用于访问 metastore 的 Hive 是什么版本，Spark SQL 内部都使用 Hive 1.2.1 版本进行编译，并且使用这个版本的一些类用于内部执行（serdes，UDFs，UDAFs等）</p>

        <p>下面的选项可用来配置用于检索元数据的Hive 版本 : </p>

        <table class="table">
            <tr><th>Property Name</th><th>Default</th><th>Meaning</th></tr>
            <tr>
                <td><code>spark.sql.hive.metastore.version</code></td>
                <td><code>1.2.1</code></td>
                <td>
                    Version of the Hive metastore. Available
                    options are <code>0.12.0</code> through <code>1.2.1</code>.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.hive.metastore.jars</code></td>
                <td><code>builtin</code></td>
                <td>
                    Location of the jars that should be used to instantiate the HiveMetastoreClient. This
                    property can be one of three options:
                    <ol>
                        <li><code>builtin</code></li>
                        Use Hive 1.2.1, which is bundled with the Spark assembly when <code>-Phive</code> is
                        enabled. When this option is chosen, <code>spark.sql.hive.metastore.version</code> must be
                        either <code>1.2.1</code> or not defined.
                        <li><code>maven</code></li>
                        Use Hive jars of specified version downloaded from Maven repositories. This configuration
                        is not generally recommended for production deployments.
                        <li>A classpath in the standard format for the JVM. This classpath must include all of Hive
                            and its dependencies, including the correct version of Hadoop. These jars only need to be
                            present on the driver, but if you are running in yarn cluster mode then you must ensure
                            they are packaged with your application.</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.hive.metastore.sharedPrefixes</code></td>
                <td><code>com.mysql.jdbc,<br />org.postgresql,<br />com.microsoft.sqlserver,<br />oracle.jdbc</code></td>
                <td>
                    <p>
                        A comma separated list of class prefixes that should be loaded using the classloader that is
                        shared between Spark SQL and a specific version of Hive. An example of classes that should
                        be shared is JDBC drivers that are needed to talk to the metastore. Other classes that need
                        to be shared are those that interact with classes that are already shared. For example,
                        custom appenders that are used by log4j.
                    </p>
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.hive.metastore.barrierPrefixes</code></td>
                <td><code>(empty)</code></td>
                <td>
                    <p>
                        A comma separated list of class prefixes that should explicitly be reloaded for each version
                        of Hive that Spark SQL is communicating with. For example, Hive UDFs that are declared in a
                        prefix that typically would be shared (i.e. <code>org.apache.spark.*</code>).
                    </p>
                </td>
            </tr>
        </table>

        <h2 id="jdbc-to-other-databases">JDBC 连接其它数据库</h2>

        <p>Spark SQL 还有一个能够使用 JDBC 从其他数据库读取数据的数据源。当使用 JDBC 访问其它数据库时，应该首选<a href="api/scala/index.html#org.apache.spark.rdd.JdbcRDD">JdbcRDD</a>.
            这是因为结果是以 DataFrame 返回的，且这样Spark SQL操作轻松或便于连接其它数据源。因为这种 JDBC 数据源不需要用户提供 ClassTag，所以它也更适合使用 Java 或 Python 操作。（注意，这与允许其它应用使用 Spark SQL 执行查询操作的 Spark SQL JDBC 服务器是不同的）。</p>

        <p>使用 JDBC 访问特定数据库时，需要在 spark classpath 上添加对应的 JDBC 驱动配置。例如，为了从 Spark Shell 连接 postgres，你需要运行如下命令 : </p>

        <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>bin/spark-shell --driver-class-path postgresql-9.4.1207.jar --jars postgresql-9.4.1207.jar</code></pre></figure>

        <p>
            可以使用Data Sources API将远程数据库中的表加载为DataFrame或Spark SQL临时视图。 用户可以在数据源选项中指定JDBC连接属性。
           <code> user</code> 和 <code>password</code>通常作为登录数据源的连接属性提供。 除连接属性外，Spark还支持以下不区分大小写的选项：
        </p>

        <table class="table">
            <tr><th>Property Name</th><th>Meaning</th></tr>
            <tr>
                <td><code>url</code></td>
                <td>
                    The JDBC URL to connect to. The source-specific connection properties may be specified in the URL. e.g., <code>jdbc:postgresql://localhost/test?user=fred&amp;password=secret</code>
                </td>
            </tr>

            <tr>
                <td><code>dbtable</code></td>
                <td>
                    The JDBC table that should be read. Note that anything that is valid in a <code>FROM</code> clause of
                    a SQL query can be used. For example, instead of a full table you could also use a
                    subquery in parentheses.
                </td>
            </tr>

            <tr>
                <td><code>driver</code></td>
                <td>
                    The class name of the JDBC driver to use to connect to this URL.
                </td>
            </tr>

            <tr>
                <td><code>partitionColumn, lowerBound, upperBound</code></td>
                <td>
                    These options must all be specified if any of them is specified. In addition,
                    <code>numPartitions</code> must be specified. They describe how to partition the table when
                    reading in parallel from multiple workers.
                    <code>partitionColumn</code> must be a numeric column from the table in question. Notice
                    that <code>lowerBound</code> and <code>upperBound</code> are just used to decide the
                    partition stride, not for filtering the rows in table. So all rows in the table will be
                    partitioned and returned. This option applies only to reading.
                </td>
            </tr>

            <tr>
                <td><code>numPartitions</code></td>
                <td>
                    The maximum number of partitions that can be used for parallelism in table reading and
                    writing. This also determines the maximum number of concurrent JDBC connections.
                    If the number of partitions to write exceeds this limit, we decrease it to this limit by
                    calling <code>coalesce(numPartitions)</code> before writing.
                </td>
            </tr>

            <tr>
                <td><code>fetchsize</code></td>
                <td>
                    The JDBC fetch size, which determines how many rows to fetch per round trip. This can help performance on JDBC drivers which default to low fetch size (eg. Oracle with 10 rows). This option applies only to reading.
                </td>
            </tr>

            <tr>
                <td><code>batchsize</code></td>
                <td>
                    The JDBC batch size, which determines how many rows to insert per round trip. This can help performance on JDBC drivers. This option applies only to writing. It defaults to <code>1000</code>.
                </td>
            </tr>

            <tr>
                <td><code>isolationLevel</code></td>
                <td>
                    The transaction isolation level, which applies to current connection. It can be one of <code>NONE</code>, <code>READ_COMMITTED</code>, <code>READ_UNCOMMITTED</code>, <code>REPEATABLE_READ</code>, or <code>SERIALIZABLE</code>, corresponding to standard transaction isolation levels defined by JDBC's Connection object, with default of <code>READ_UNCOMMITTED</code>. This option applies only to writing. Please refer the documentation in <code>java.sql.Connection</code>.
                </td>
            </tr>

            <tr>
                <td><code>sessionInitStatement</code></td>
                <td>
                    After each database session is opened to the remote DB and before starting to read data, this option executes a custom SQL statement (or a PL/SQL block). Use this to implement session initialization code. Example: <code>option("sessionInitStatement", """BEGIN execute immediate 'alter session set "_serial_direct_read"=true'; END;""")</code>
                </td>
            </tr>

            <tr>
                <td><code>truncate</code></td>
                <td>
                    This is a JDBC writer related option. When <code>SaveMode.Overwrite</code> is enabled, this option causes Spark to truncate an existing table instead of dropping and recreating it. This can be more efficient, and prevents the table metadata (e.g., indices) from being removed. However, it will not work in some cases, such as when the new data has a different schema. It defaults to <code>false</code>. This option applies only to writing.
                </td>
            </tr>

            <tr>
                <td><code>createTableOptions</code></td>
                <td>
                    This is a JDBC writer related option. If specified, this option allows setting of database-specific table and partition options when creating a table (e.g., <code>CREATE TABLE t (name string) ENGINE=InnoDB.</code>). This option applies only to writing.
                </td>
            </tr>

            <tr>
                <td><code>createTableColumnTypes</code></td>
                <td>
                    The database column data types to use instead of the defaults, when creating the table. Data type information should be specified in the same format as CREATE TABLE columns syntax (e.g: <code>"name CHAR(64), comments VARCHAR(1024)")</code>. The specified types should be valid spark sql data types. This option applies only to writing.
                </td>
            </tr>

            <tr>
                <td><code>customSchema</code></td>
                <td>
                    The custom schema to use for reading data from JDBC connectors. For example, <code>"id DECIMAL(38, 0), name STRING"</code>. You can also specify partial fields, and the others use the default type mapping. For example, <code>"id DECIMAL(38, 0)"</code>. The column names should be identical to the corresponding column names of JDBC table. Users can specify the corresponding data types of Spark SQL instead of using the defaults. This option applies only to reading.
                </td>
            </tr>
        </table>

        <div class="codetabs">

            <div data-lang="scala">
                <div class="highlight"><pre><span></span><span class="c1">// Note: JDBC loading and saving can be achieved via either the load/save or jdbc methods</span>
<span class="c1">// Loading data from a JDBC source</span>
<span class="k">val</span> <span class="n">jdbcDF</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span>
  <span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;jdbc&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;url&quot;</span><span class="o">,</span> <span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;dbtable&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;username&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">load</span><span class="o">()</span>

<span class="k">val</span> <span class="n">connectionProperties</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">()</span>
<span class="n">connectionProperties</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;username&quot;</span><span class="o">)</span>
<span class="n">connectionProperties</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">jdbcDF2</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span>
  <span class="o">.</span><span class="n">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">)</span>
<span class="c1">// Specifying the custom data types of the read schema</span>
<span class="n">connectionProperties</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">&quot;customSchema&quot;</span><span class="o">,</span> <span class="s">&quot;id DECIMAL(38, 0), name STRING&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">jdbcDF3</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span>
  <span class="o">.</span><span class="n">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">)</span>

<span class="c1">// Saving data to a JDBC source</span>
<span class="n">jdbcDF</span><span class="o">.</span><span class="n">write</span>
  <span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="s">&quot;jdbc&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;url&quot;</span><span class="o">,</span> <span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;dbtable&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;username&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">save</span><span class="o">()</span>

<span class="n">jdbcDF2</span><span class="o">.</span><span class="n">write</span>
  <span class="o">.</span><span class="n">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">)</span>

<span class="c1">// Specifying create table column data types on write</span>
<span class="n">jdbcDF</span><span class="o">.</span><span class="n">write</span>
  <span class="o">.</span><span class="n">option</span><span class="o">(</span><span class="s">&quot;createTableColumnTypes&quot;</span><span class="o">,</span> <span class="s">&quot;name CHAR(64), comments VARCHAR(1024)&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="n">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">)</span>
</pre></div>
                <div><small>在 Spark Repo中"examples/src/main/scala/org/apache/spark/examples/sql/SQLDataSourceExample.scala" 可以查看完整的示例代码。</small></div>
            </div>

            <div data-lang="java">
                <div class="highlight"><pre><span></span><span class="c1">// Note: JDBC loading and saving can be achieved via either the load/save or jdbc methods</span>
<span class="c1">// Loading data from a JDBC source</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">jdbcDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">()</span>
  <span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;jdbc&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;url&quot;</span><span class="o">,</span> <span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;dbtable&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;username&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">load</span><span class="o">();</span>

<span class="n">Properties</span> <span class="n">connectionProperties</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Properties</span><span class="o">();</span>
<span class="n">connectionProperties</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;username&quot;</span><span class="o">);</span>
<span class="n">connectionProperties</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">);</span>
<span class="n">Dataset</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">jdbcDF2</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="na">read</span><span class="o">()</span>
  <span class="o">.</span><span class="na">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">);</span>

<span class="c1">// Saving data to a JDBC source</span>
<span class="n">jdbcDF</span><span class="o">.</span><span class="na">write</span><span class="o">()</span>
  <span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;jdbc&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;url&quot;</span><span class="o">,</span> <span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;dbtable&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;username&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;password&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">save</span><span class="o">();</span>

<span class="n">jdbcDF2</span><span class="o">.</span><span class="na">write</span><span class="o">()</span>
  <span class="o">.</span><span class="na">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">);</span>

<span class="c1">// Specifying create table column data types on write</span>
<span class="n">jdbcDF</span><span class="o">.</span><span class="na">write</span><span class="o">()</span>
  <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="s">&quot;createTableColumnTypes&quot;</span><span class="o">,</span> <span class="s">&quot;name CHAR(64), comments VARCHAR(1024)&quot;</span><span class="o">)</span>
  <span class="o">.</span><span class="na">jdbc</span><span class="o">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="o">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="o">,</span> <span class="n">connectionProperties</span><span class="o">);</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/java/org/apache/spark/examples/sql/JavaSQLDataSourceExample.java" in the Spark repo.</small></div>
            </div>

            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="c1"># Note: JDBC loading and saving can be achieved via either the load/save or jdbc methods</span>
<span class="c1"># Loading data from a JDBC source</span>
<span class="n">jdbcDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span> \
    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;jdbc&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;dbtable&quot;</span><span class="p">,</span> <span class="s2">&quot;schema.tablename&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;username&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;password&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">load</span><span class="p">()</span>

<span class="n">jdbcDF2</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span> \
    <span class="o">.</span><span class="n">jdbc</span><span class="p">(</span><span class="s2">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">,</span> <span class="s2">&quot;schema.tablename&quot;</span><span class="p">,</span>
          <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="s2">&quot;username&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="s2">&quot;password&quot;</span><span class="p">})</span>

<span class="c1"># Specifying dataframe column data types on read</span>
<span class="n">jdbcDF3</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span> \
    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;jdbc&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;dbtable&quot;</span><span class="p">,</span> <span class="s2">&quot;schema.tablename&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;username&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;password&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;customSchema&quot;</span><span class="p">,</span> <span class="s2">&quot;id DECIMAL(38, 0), name STRING&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">load</span><span class="p">()</span>

<span class="c1"># Saving data to a JDBC source</span>
<span class="n">jdbcDF</span><span class="o">.</span><span class="n">write</span> \
    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;jdbc&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;url&quot;</span><span class="p">,</span> <span class="s2">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;dbtable&quot;</span><span class="p">,</span> <span class="s2">&quot;schema.tablename&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;username&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;password&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">save</span><span class="p">()</span>

<span class="n">jdbcDF2</span><span class="o">.</span><span class="n">write</span> \
    <span class="o">.</span><span class="n">jdbc</span><span class="p">(</span><span class="s2">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">,</span> <span class="s2">&quot;schema.tablename&quot;</span><span class="p">,</span>
          <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="s2">&quot;username&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="s2">&quot;password&quot;</span><span class="p">})</span>

<span class="c1"># Specifying create table column data types on write</span>
<span class="n">jdbcDF</span><span class="o">.</span><span class="n">write</span> \
    <span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="s2">&quot;createTableColumnTypes&quot;</span><span class="p">,</span> <span class="s2">&quot;name CHAR(64), comments VARCHAR(1024)&quot;</span><span class="p">)</span> \
    <span class="o">.</span><span class="n">jdbc</span><span class="p">(</span><span class="s2">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">,</span> <span class="s2">&quot;schema.tablename&quot;</span><span class="p">,</span>
          <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="s2">&quot;username&quot;</span><span class="p">,</span> <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="s2">&quot;password&quot;</span><span class="p">})</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/datasource.py" in the Spark repo.</small></div>
            </div>

            <div data-lang="r">
                <div class="highlight"><pre><span></span><span class="c1"># Loading data from a JDBC source</span>
df <span class="o">&lt;-</span> read.jdbc<span class="p">(</span><span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="p">,</span> user <span class="o">=</span> <span class="s">&quot;username&quot;</span><span class="p">,</span> password <span class="o">=</span> <span class="s">&quot;password&quot;</span><span class="p">)</span>

<span class="c1"># Saving data to a JDBC source</span>
write.jdbc<span class="p">(</span>df<span class="p">,</span> <span class="s">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">,</span> <span class="s">&quot;schema.tablename&quot;</span><span class="p">,</span> user <span class="o">=</span> <span class="s">&quot;username&quot;</span><span class="p">,</span> password <span class="o">=</span> <span class="s">&quot;password&quot;</span><span class="p">)</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/r/RSparkSQLExample.R" in the Spark repo.</small></div>
            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="k">CREATE</span> <span class="k">TEMPORARY</span> <span class="k">VIEW</span> <span class="n">jdbcTable</span>
<span class="k">USING</span> <span class="n">org</span><span class="p">.</span><span class="n">apache</span><span class="p">.</span><span class="n">spark</span><span class="p">.</span><span class="k">sql</span><span class="p">.</span><span class="n">jdbc</span>
<span class="k">OPTIONS</span> <span class="p">(</span>
  <span class="n">url</span> <span class="ss">&quot;jdbc:postgresql:dbserver&quot;</span><span class="p">,</span>
  <span class="n">dbtable</span> <span class="ss">&quot;schema.tablename&quot;</span><span class="p">,</span>
  <span class="k">user</span> <span class="s1">&#39;username&#39;</span><span class="p">,</span>
  <span class="n">password</span> <span class="s1">&#39;password&#39;</span>
<span class="p">)</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">jdbcTable</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">resultTable</span></code></pre></figure>

            </div>
        </div>

        <h2 id="troubleshooting">故障排除</h2>

        <ul>
            <li>JDBC驱动程序类必须对客户端会话和所有执行程序上的原始类加载器可见。 这是因为Java的DriverManager类进行了安全检查，
                导致它忽略了当打开连接时原始类加载器不可见的所有驱动程序。 一种方便的方法是修改所有工作节点上的compute_classpath.sh
                以包含驱动程序JAR。</li>
            <li>某些数据库（如H2）会将所有名称转换为大写。 您需要使用大写字母在Spark SQL中引用这些名称。</li>
        </ul>

        <h1 id="performance-tuning">性能调优</h1>

        <p>
            对于某些工作负载，可以通过在内存中缓存数据或打开一些选项来提高性能。</p>

        <h2 id="caching-data-in-memory">在内存中缓存数据</h2>

        <p>Spark SQL 可以通过调用
            <code>spark.catalog.cacheTable("tableName")</code> 或 <code>dataFrame.cache()</code> 以列存储格式缓存表到内存中。随后，
            Spark SQL 将会扫描必要的列，并自动调整压缩比例，以减少内存占用和 GC 压力。你可以调用
            <code>spark.catalog.uncacheTable("tableName")</code>
            来删除内存中的表。</p>

        <p>
            你可以在 <code>SparkSession</code> 上使用 <code>setConf</code> 方法或在 SQL 语句中运行 <code>SET key=value</code> 命令，来配置内存中的缓存。
        </p>

        <table class="table">
            <tr><th>Property Name</th><th>Default</th><th>Meaning</th></tr>
            <tr>
                <td><code>spark.sql.inMemoryColumnarStorage.compressed</code></td>
                <td>true</td>
                <td>
                    When set to true Spark SQL will automatically select a compression codec for each column based
                    on statistics of the data.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.inMemoryColumnarStorage.batchSize</code></td>
                <td>10000</td>
                <td>
                    Controls the size of batches for columnar caching. Larger batch sizes can improve memory utilization
                    and compression, but risk OOMs when caching data.
                </td>
            </tr>

        </table>

        <h2 id="other-configuration-options">其它配置选项</h2>

        <p>下面的选项也可以用来提升查询执行的性能。这些选项在未来的发布版本中可能会过时。</p>

        <table class="table">
            <tr><th>Property Name</th><th>Default</th><th>Meaning</th></tr>
            <tr>
                <td><code>spark.sql.files.maxPartitionBytes</code></td>
                <td>134217728 (128 MB)</td>
                <td>
                    The maximum number of bytes to pack into a single partition when reading files.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.files.openCostInBytes</code></td>
                <td>4194304 (4 MB)</td>
                <td>
                    The estimated cost to open a file, measured by the number of bytes could be scanned in the same
                    time. This is used when putting multiple files into a partition. It is better to over estimated,
                    then the partitions with small files will be faster than partitions with bigger files (which is
                    scheduled first).
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.broadcastTimeout</code></td>
                <td>300</td>
                <td>
                    <p>
                        Timeout in seconds for the broadcast wait time in broadcast joins
                    </p>
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.autoBroadcastJoinThreshold</code></td>
                <td>10485760 (10 MB)</td>
                <td>
                    Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when
                    performing a join. By setting this value to -1 broadcasting can be disabled. Note that currently
                    statistics are only supported for Hive Metastore tables where the command
                    <code>ANALYZE TABLE &lt;tableName&gt; COMPUTE STATISTICS noscan</code> has been run.
                </td>
            </tr>
            <tr>
                <td><code>spark.sql.shuffle.partitions</code></td>
                <td>200</td>
                <td>
                    Configures the number of partitions to use when shuffling data for joins or aggregations.
                </td>
            </tr>
        </table>

        <h2 id="broadcast-hint-for-sql-queries">SQL查询的广播提示</h2>

        <p>
            <code>BROADCAST</code>提示指导Spark在将其与另一个表或视图连接时广播每个指定的表。 当Spark决定连接方法时，广播散列连接（即BHJ）是首选，
            即使统计信息高于配置<code>spark.sql.autoBroadcastJoinThreshold</code>。 指定连接的两端时，Spark会广播具有较低统计信息的那一方。
            注意Spark并不保证始终选择BHJ，因为并非所有情况（例如全外连接）都支持BHJ。 当选择广播嵌套循环连接时，我们仍然尊重提示。
        </p>

        <div class="codetabs">

            <div data-lang="scala">

                <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="k">import</span> <span class="nn">org.apache.spark.sql.functions.broadcast</span>
<span class="n">broadcast</span><span class="o">(</span><span class="n">spark</span><span class="o">.</span><span class="n">table</span><span class="o">(</span><span class="s">&quot;src&quot;</span><span class="o">)).</span><span class="n">join</span><span class="o">(</span><span class="n">spark</span><span class="o">.</span><span class="n">table</span><span class="o">(</span><span class="s">&quot;records&quot;</span><span class="o">),</span> <span class="s">&quot;key&quot;</span><span class="o">).</span><span class="n">show</span><span class="o">()</span></code></pre></figure>

            </div>

            <div data-lang="java">

                <figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="kn">import static</span> <span class="nn">org.apache.spark.sql.functions.broadcast</span><span class="o">;</span>
<span class="n">broadcast</span><span class="o">(</span><span class="n">spark</span><span class="o">.</span><span class="na">table</span><span class="o">(</span><span class="s">&quot;src&quot;</span><span class="o">)).</span><span class="na">join</span><span class="o">(</span><span class="n">spark</span><span class="o">.</span><span class="na">table</span><span class="o">(</span><span class="s">&quot;records&quot;</span><span class="o">),</span> <span class="s">&quot;key&quot;</span><span class="o">).</span><span class="na">show</span><span class="o">();</span></code></pre></figure>

            </div>

            <div data-lang="python">

                <figure class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="kn">from</span> <span class="nn">pyspark.sql.functions</span> <span class="kn">import</span> <span class="n">broadcast</span>
<span class="n">broadcast</span><span class="p">(</span><span class="n">spark</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">spark</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="s2">&quot;records&quot;</span><span class="p">),</span> <span class="s2">&quot;key&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></figure>

            </div>

            <div data-lang="r">

                <figure class="highlight"><pre><code class="language-r" data-lang="r"><span></span>src <span class="o">&lt;-</span> sql<span class="p">(</span><span class="s">&quot;SELECT * FROM src&quot;</span><span class="p">)</span>
records <span class="o">&lt;-</span> sql<span class="p">(</span><span class="s">&quot;SELECT * FROM records&quot;</span><span class="p">)</span>
<span class="kp">head</span><span class="p">(</span>join<span class="p">(</span>broadcast<span class="p">(</span>src<span class="p">),</span> records<span class="p">,</span> src<span class="o">$</span>key <span class="o">==</span> records<span class="o">$</span>key<span class="p">))</span></code></pre></figure>

            </div>

            <div data-lang="sql">

                <figure class="highlight"><pre><code class="language-sql" data-lang="sql"><span></span><span class="c1">-- We accept BROADCAST, BROADCASTJOIN and MAPJOIN for broadcast hint</span>
<span class="k">SELECT</span> <span class="cm">/*+ BROADCAST(r) */</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">records</span> <span class="n">r</span> <span class="k">JOIN</span> <span class="n">src</span> <span class="n">s</span> <span class="k">ON</span> <span class="n">r</span><span class="p">.</span><span class="k">key</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="k">key</span></code></pre></figure>

            </div>
        </div>

        <h1 id="distributed-sql-engine">分布式 SQL引擎</h1>

        <p>Spark SQL还可以使用其JDBC / ODBC或命令行界面充当分布式查询引擎。
            在此模式下，最终用户或应用程序可以直接与Spark SQL交互以运行SQL查询，无需编写任何代码。</p>

        <h2 id="running-the-thrift-jdbcodbc-server">运行 Thrift JDBC/ODBC server</h2>

        <p>
            这里实现的 Thrift JDBC/ODBC server 对应于 Hive 1.2.1 版本中的 <a href="https://cwiki.apache.org/confluence/display/Hive/Setting+Up+HiveServer2"><code>HiveServer2</code></a> 你可以使用 Spark 或者 Hive 1.2.1 自带的 beeline 脚本来测试这个 JDBC server。
        </p>

        <p>要启动 JDBC/ODBC server， 需要在 Spark 安装目录下运行如下命令 : </p>

        <pre><code>./sbin/start-thriftserver.sh
</code></pre>

        <p>这个脚本能接受所有<code>bin/spark-submit</code> 命令行选项，以及<code>--hiveconf</code>选项以指定Hive属性。
            您可以运行 <code>./sbin/start-thriftserver.sh --help</code> 以获取所有可用选项的完整列表。
            默认情况下，服务器侦听localhost：10000。 您可以通过任一环境变量覆盖此行为，即：
        </p>

        <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span><span class="nb">export</span> <span class="nv">HIVE_SERVER2_THRIFT_PORT</span><span class="o">=</span>&lt;listening-port&gt;
<span class="nb">export</span> <span class="nv">HIVE_SERVER2_THRIFT_BIND_HOST</span><span class="o">=</span>&lt;listening-host&gt;
./sbin/start-thriftserver.sh <span class="se">\</span>
  --master &lt;master-uri&gt; <span class="se">\</span>
  ...</code></pre></figure>

        <p>或者系统属性 : </p>

        <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>./sbin/start-thriftserver.sh <span class="se">\</span>
  --hiveconf hive.server2.thrift.port<span class="o">=</span>&lt;listening-port&gt; <span class="se">\</span>
  --hiveconf hive.server2.thrift.bind.host<span class="o">=</span>&lt;listening-host&gt; <span class="se">\</span>
  --master &lt;master-uri&gt;
  ...</code></pre></figure>

        <p>现在你可以使用 beeline 来测试这个Thrift JDBC/ODBC server : </p>

        <pre><code>./bin/beeline
</code></pre>

        <p>在 beeline 中使用以下命令连接到 JDBC/ODBC server : </p>

        <pre><code>beeline&gt; !connect jdbc:hive2://localhost:10000
</code></pre>

        <p>Beeline 会要求你输入用户名和密码。在非安全模式下，只需要输入你本机的用户名和一个空密码即可。对于安全模式，请参考
            <a href="https://cwiki.apache.org/confluence/display/Hive/HiveServer2+Clients"> beeline 文档</a>。</p>

        <p>将<code>hive-site.xml</code>, <code>core-site.xml</code> 和 <code>hdfs-site.xml</code> 文件放置在
            <code>conf/</code>目录下可以完成 Hive 配置。</p>

        <p>你也可以使用 Hive 自带的 beeline 的脚本。</p>

        <p>Thrift JDBC server 还支持通过 HTTP 传输来发送 Thrift RPC 消息
            使用下面的设置作为系统属性或者对 <code>conf/</code> 目录中的 <code>hive-site.xml</code>  文件配置来启用 HTTP 模式 :
        </p>

        <pre><code>hive.server2.transport.mode - Set this to value: http
hive.server2.thrift.http.port - HTTP port number to listen on; default is 10001
hive.server2.http.endpoint - HTTP endpoint; default is cliservice
</code></pre>

        <p>为了测试，在 HTTP 模式中使用 beeline 连接到 JDBC/ODBC server : </p>

        <pre><code>beeline&gt; !connect jdbc:hive2://&lt;host&gt;:&lt;port&gt;/&lt;database&gt;?hive.server2.transport.mode=http;hive.server2.thrift.http.path=&lt;http_endpoint&gt;
</code></pre>

        <h2 id="running-the-spark-sql-cli">运行 Spark SQL CLI</h2>

        <p>Spark SQL CLI 是一个很方便的工具，它可以在本地模式下运行 Hive metastore 服务，并且执行从命令行中输入的查询语句。
            请注意，Spark SQL CLI无法与Thrift JDBC服务器通信。
        </p>

        <p>要启动Spark SQL CLI，请在Spark目录中运行以下命令：</p>

        <pre><code>./bin/spark-sql
</code></pre>

        <p>将<code>hive-site.xml</code>, <code>core-site.xml</code> 和 <code>hdfs-site.xml</code>
            文件放置在 <code>conf/</code> 目录下可以完成 Hive 配置。你可以运行 <code>./bin/spark-sql --help</code> 来获取所有可用选项的完整列表。
        </p>

        <h1 id="pyspark-usage-guide-for-pandas-with-apache-arrow">PySpark Usage Guide for Pandas with Apache Arrow</h1>

        <h2 id="apache-arrow-in-spark">Apache Arrow in Spark</h2>

        <p>Apache Arrow is an in-memory columnar data format that is used in Spark to efficiently transfer
            data between JVM and Python processes. This currently is most beneficial to Python users that
            work with Pandas/NumPy data. Its usage is not automatic and might require some minor
            changes to configuration or code to take full advantage and ensure compatibility. This guide will
            give a high-level description of how to use Arrow in Spark and highlight any differences when
            working with Arrow-enabled data.</p>

        <h3 id="ensure-pyarrow-installed">Ensure PyArrow Installed</h3>

        <p>If you install PySpark using pip, then PyArrow can be brought in as an extra dependency of the
            SQL module with the command <code>pip install pyspark[sql]</code>. Otherwise, you must ensure that PyArrow
            is installed and available on all cluster nodes. The current supported version is 0.8.0.
            You can install using pip or conda from the conda-forge channel. See PyArrow
            <a href="https://arrow.apache.org/docs/python/install.html">installation</a> for details.</p>

        <h2 id="enabling-for-conversion-tofrom-pandas">Enabling for Conversion to/from Pandas</h2>

        <p>Arrow is available as an optimization when converting a Spark DataFrame to a Pandas DataFrame
            using the call <code>toPandas()</code> and when creating a Spark DataFrame from a Pandas DataFrame with
            <code>createDataFrame(pandas_df)</code>. To use Arrow when executing these calls, users need to first set
            the Spark configuration &#8216;spark.sql.execution.arrow.enabled&#8217; to &#8216;true&#8217;. This is disabled by default.</p>

        <div class="codetabs">
            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="c1"># Enable Arrow-based columnar data transfers</span>
<span class="n">spark</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;spark.sql.execution.arrow.enabled&quot;</span><span class="p">,</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span>

<span class="c1"># Generate a Pandas DataFrame</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="c1"># Create a Spark DataFrame from a Pandas DataFrame using Arrow</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>

<span class="c1"># Convert the Spark DataFrame back to a Pandas DataFrame using Arrow</span>
<span class="n">result_pdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">toPandas</span><span class="p">()</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/arrow.py" in the Spark repo.</small></div>
            </div>
        </div>

        <p>Using the above optimizations with Arrow will produce the same results as when Arrow is not
            enabled. Note that even with Arrow, <code>toPandas()</code> results in the collection of all records in the
            DataFrame to the driver program and should be done on a small subset of the data. Not all Spark
            data types are currently supported and an error can be raised if a column has an unsupported type,
            see <a href="#supported-sql-types">Supported SQL Types</a>. If an error occurs during <code>createDataFrame()</code>,
            Spark will fall back to create the DataFrame without Arrow.</p>

        <h2 id="pandas-udfs-aka-vectorized-udfs">Pandas UDFs (a.k.a. Vectorized UDFs)</h2>

        <p>Pandas UDFs are user defined functions that are executed by Spark using Arrow to transfer data and
            Pandas to work with the data. A Pandas UDF is defined using the keyword <code>pandas_udf</code> as a decorator
            or to wrap the function, no additional configuration is required. Currently, there are two types of
            Pandas UDF: Scalar and Grouped Map.</p>

        <h3 id="scalar">Scalar</h3>

        <p>Scalar Pandas UDFs are used for vectorizing scalar operations. They can be used with functions such
            as <code>select</code> and <code>withColumn</code>. The Python function should take <code>pandas.Series</code> as inputs and return
            a <code>pandas.Series</code> of the same length. Internally, Spark will execute a Pandas UDF by splitting
            columns into batches and calling the function for each batch as a subset of the data, then
            concatenating the results together.</p>

        <p>The following example shows how to create a scalar Pandas UDF that computes the product of 2 columns.</p>

        <div class="codetabs">
            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">pyspark.sql.functions</span> <span class="kn">import</span> <span class="n">col</span><span class="p">,</span> <span class="n">pandas_udf</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="kn">import</span> <span class="n">LongType</span>

<span class="c1"># Declare the function and create the UDF</span>
<span class="k">def</span> <span class="nf">multiply_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="n">multiply</span> <span class="o">=</span> <span class="n">pandas_udf</span><span class="p">(</span><span class="n">multiply_func</span><span class="p">,</span> <span class="n">returnType</span><span class="o">=</span><span class="n">LongType</span><span class="p">())</span>

<span class="c1"># The function for a pandas_udf should be able to execute with local Pandas data</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">multiply_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="c1"># 0    1</span>
<span class="c1"># 1    4</span>
<span class="c1"># 2    9</span>
<span class="c1"># dtype: int64</span>

<span class="c1"># Create a Spark DataFrame, &#39;spark&#39; is an existing SparkSession</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]))</span>

<span class="c1"># Execute function as a Spark vectorized UDF</span>
<span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">multiply</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">col</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +-------------------+</span>
<span class="c1"># |multiply_func(x, x)|</span>
<span class="c1"># +-------------------+</span>
<span class="c1"># |                  1|</span>
<span class="c1"># |                  4|</span>
<span class="c1"># |                  9|</span>
<span class="c1"># +-------------------+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/arrow.py" in the Spark repo.</small></div>
            </div>
        </div>

        <h3 id="grouped-map">Grouped Map</h3>
        <p>Grouped map Pandas UDFs are used with <code>groupBy().apply()</code> which implements the &#8220;split-apply-combine&#8221; pattern.
            Split-apply-combine consists of three steps:</p>
        <ul>
            <li>Split the data into groups by using <code>DataFrame.groupBy</code>.</li>
            <li>Apply a function on each group. The input and output of the function are both <code>pandas.DataFrame</code>. The
                input data contains all the rows and columns for each group.</li>
            <li>Combine the results into a new <code>DataFrame</code>.</li>
        </ul>

        <p>To use <code>groupBy().apply()</code>, the user needs to define the following:</p>
        <ul>
            <li>A Python function that defines the computation for each group.</li>
            <li>A <code>StructType</code> object or a string that defines the schema of the output <code>DataFrame</code>.</li>
        </ul>

        <p>The output schema will be applied to the columns of the returned <code>pandas.DataFrame</code> in order by position,
            not by name. This means that the columns in the <code>pandas.DataFrame</code> must be indexed so that their
            position matches the corresponding field in the schema.</p>

        <p>Note that when creating a new <code>pandas.DataFrame</code> using a dictionary, the actual position of the column
            can differ from the order that it was placed in the dictionary. It is recommended in this case to
            explicitly define the column order using the <code>columns</code> keyword, e.g.
            <code>pandas.DataFrame({'id': ids, 'a': data}, columns=['id', 'a'])</code>, or alternatively use an <code>OrderedDict</code>.</p>

        <p>Note that all data for a group will be loaded into memory before the function is applied. This can
            lead to out of memory exceptons, especially if the group sizes are skewed. The configuration for
            <a href="#setting-arrow-batch-size">maxRecordsPerBatch</a> is not applied on groups and it is up to the user
            to ensure that the grouped data will fit into the available memory.</p>

        <p>The following example shows how to use <code>groupby().apply()</code> to subtract the mean from each value in the group.</p>

        <div class="codetabs">
            <div data-lang="python">
                <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyspark.sql.functions</span> <span class="kn">import</span> <span class="n">pandas_udf</span><span class="p">,</span> <span class="n">PandasUDFType</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span>
    <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)],</span>
    <span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">))</span>

<span class="nd">@pandas_udf</span><span class="p">(</span><span class="s2">&quot;id long, v double&quot;</span><span class="p">,</span> <span class="n">PandasUDFType</span><span class="o">.</span><span class="n">GROUPED_MAP</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">substract_mean</span><span class="p">(</span><span class="n">pdf</span><span class="p">):</span>
    <span class="c1"># pdf is a pandas.DataFrame</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">pdf</span><span class="o">.</span><span class="n">v</span>
    <span class="k">return</span> <span class="n">pdf</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">v</span> <span class="o">-</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

<span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">substract_mean</span><span class="p">)</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c1"># +---+----+</span>
<span class="c1"># | id|   v|</span>
<span class="c1"># +---+----+</span>
<span class="c1"># |  1|-0.5|</span>
<span class="c1"># |  1| 0.5|</span>
<span class="c1"># |  2|-3.0|</span>
<span class="c1"># |  2|-1.0|</span>
<span class="c1"># |  2| 4.0|</span>
<span class="c1"># +---+----+</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/python/sql/arrow.py" in the Spark repo.</small></div>
            </div>
        </div>

        <p>For detailed usage, please see <a href="api/python/pyspark.sql.html#pyspark.sql.functions.pandas_udf"><code>pyspark.sql.functions.pandas_udf</code></a> and
            <a href="api/python/pyspark.sql.html#pyspark.sql.GroupedData.apply"><code>pyspark.sql.GroupedData.apply</code></a>.</p>

        <h2 id="usage-notes">Usage Notes</h2>

        <h3 id="supported-sql-types">Supported SQL Types</h3>

        <p>Currently, all Spark SQL data types are supported by Arrow-based conversion except <code>BinaryType</code>, <code>MapType</code>,
            <code>ArrayType</code> of <code>TimestampType</code>, and nested <code>StructType</code>.</p>

        <h3 id="setting-arrow-batch-size">Setting Arrow Batch Size</h3>

        <p>Data partitions in Spark are converted into Arrow record batches, which can temporarily lead to
            high memory usage in the JVM. To avoid possible out of memory exceptions, the size of the Arrow
            record batches can be adjusted by setting the conf &#8220;spark.sql.execution.arrow.maxRecordsPerBatch&#8221;
            to an integer that will determine the maximum number of rows for each batch. The default value is
            10,000 records per batch. If the number of columns is large, the value should be adjusted
            accordingly. Using this limit, each data partition will be made into 1 or more record batches for
            processing.</p>

        <h3 id="timestamp-with-time-zone-semantics">Timestamp with Time Zone Semantics</h3>

        <p>Spark internally stores timestamps as UTC values, and timestamp data that is brought in without
            a specified time zone is converted as local time to UTC with microsecond resolution. When timestamp
            data is exported or displayed in Spark, the session time zone is used to localize the timestamp
            values. The session time zone is set with the configuration &#8216;spark.sql.session.timeZone&#8217; and will
            default to the JVM system local time zone if not set. Pandas uses a <code>datetime64</code> type with nanosecond
            resolution, <code>datetime64[ns]</code>, with optional time zone on a per-column basis.</p>

        <p>When timestamp data is transferred from Spark to Pandas it will be converted to nanoseconds
            and each column will be converted to the Spark session time zone then localized to that time
            zone, which removes the time zone and displays values as local time. This will occur
            when calling <code>toPandas()</code> or <code>pandas_udf</code> with timestamp columns.</p>

        <p>When timestamp data is transferred from Pandas to Spark, it will be converted to UTC microseconds. This
            occurs when calling <code>createDataFrame</code> with a Pandas DataFrame or when returning a timestamp from a
            <code>pandas_udf</code>. These conversions are done automatically to ensure Spark will have data in the
            expected format, so it is not necessary to do any of these conversions yourself. Any nanosecond
            values will be truncated.</p>

        <p>Note that a standard UDF (non-Pandas) will load timestamp data as Python datetime objects, which is
            different than a Pandas timestamp. It is recommended to use Pandas time series functionality when
            working with timestamps in <code>pandas_udf</code>s to get the best performance, see
            <a href="https://pandas.pydata.org/pandas-docs/stable/timeseries.html">here</a> for details.</p>

        <h1 id="migration-guide">迁移指南</h1>

        <h2 id="upgrading-from-spark-sql-230-to-231-and-above">从Spark SQL 2.3.0升级到2.3.1及更高版本</h2>

        <ul>
            <li>
                从版本2.3.1开始，Arrow 功能（包括<code>pandas_udf</code> 和 <code>toPandas()</code>/<code>createDataFrame()</code>
                以及<code>spark.sql.execution.arrow.enabled</code>设置为<code>True</code>，已标记为实验性。 这些仍在不断发展，目前尚未推荐用于生产。
            </li>
        </ul>

        <h2 id="upgrading-from-spark-sql-22-to-23">从Spark SQL 2.2升级到2.3</h2>

        <ul>
            <li>Since Spark 2.3, the queries from raw JSON/CSV files are disallowed when the referenced columns only include the internal corrupt record column (named <code>_corrupt_record</code> by default). For example, <code>spark.read.schema(schema).json(file).filter($"_corrupt_record".isNotNull).count()</code> and <code>spark.read.schema(schema).json(file).select("_corrupt_record").show()</code>. Instead, you can cache or save the parsed results and then send the same query. For example, <code>val df = spark.read.schema(schema).json(file).cache()</code> and then <code>df.filter($"_corrupt_record".isNotNull).count()</code>.</li>
            <li>The <code>percentile_approx</code> function previously accepted numeric type input and output double type results. Now it supports date type, timestamp type and numeric types as input types. The result type is also changed to be the same as the input type, which is more reasonable for percentiles.</li>
            <li>Since Spark 2.3, the Join/Filter&#8217;s deterministic predicates that are after the first non-deterministic predicates are also pushed down/through the child operators, if possible. In prior Spark versions, these filters are not eligible for predicate pushdown.</li>
            <li>
                <p>Partition column inference previously found incorrect common type for different inferred types, for example, previously it ended up with double type as the common type for double type and date type. Now it finds the correct common type for such conflicts. The conflict resolution follows the table below:</p>

                <table class="table">
                    <tr>
                        <th>
                            <b>InputA \ InputB</b>
                        </th>
                        <th>
                            <b>NullType</b>
                        </th>
                        <th>
                            <b>IntegerType</b>
                        </th>
                        <th>
                            <b>LongType</b>
                        </th>
                        <th>
                            <b>DecimalType(38,0)*</b>
                        </th>
                        <th>
                            <b>DoubleType</b>
                        </th>
                        <th>
                            <b>DateType</b>
                        </th>
                        <th>
                            <b>TimestampType</b>
                        </th>
                        <th>
                            <b>StringType</b>
                        </th>
                    </tr>
                    <tr>
                        <td>
                            <b>NullType</b>
                        </td>
                        <td>NullType</td>
                        <td>IntegerType</td>
                        <td>LongType</td>
                        <td>DecimalType(38,0)</td>
                        <td>DoubleType</td>
                        <td>DateType</td>
                        <td>TimestampType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>IntegerType</b>
                        </td>
                        <td>IntegerType</td>
                        <td>IntegerType</td>
                        <td>LongType</td>
                        <td>DecimalType(38,0)</td>
                        <td>DoubleType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>LongType</b>
                        </td>
                        <td>LongType</td>
                        <td>LongType</td>
                        <td>LongType</td>
                        <td>DecimalType(38,0)</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>DecimalType(38,0)*</b>
                        </td>
                        <td>DecimalType(38,0)</td>
                        <td>DecimalType(38,0)</td>
                        <td>DecimalType(38,0)</td>
                        <td>DecimalType(38,0)</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>DoubleType</b>
                        </td>
                        <td>DoubleType</td>
                        <td>DoubleType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>DoubleType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>DateType</b>
                        </td>
                        <td>DateType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>DateType</td>
                        <td>TimestampType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>TimestampType</b>
                        </td>
                        <td>TimestampType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>TimestampType</td>
                        <td>TimestampType</td>
                        <td>StringType</td>
                    </tr>
                    <tr>
                        <td>
                            <b>StringType</b>
                        </td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                        <td>StringType</td>
                    </tr>
                </table>

                <p>Note that, for <b>DecimalType(38,0)*</b>, the table above intentionally does not cover all other combinations of scales and precisions because currently we only infer decimal type like <code>BigInteger</code>/<code>BigInt</code>. For example, 1.1 is inferred as double type.</p>
            </li>
            <li>In PySpark, now we need Pandas 0.19.2 or upper if you want to use Pandas related functionalities, such as <code>toPandas</code>, <code>createDataFrame</code> from Pandas DataFrame, etc.</li>
            <li>In PySpark, the behavior of timestamp values for Pandas related functionalities was changed to respect session timezone. If you want to use the old behavior, you need to set a configuration <code>spark.sql.execution.pandas.respectSessionTimeZone</code> to <code>False</code>. See <a href="https://issues.apache.org/jira/browse/SPARK-22395">SPARK-22395</a> for details.</li>
            <li>In PySpark, <code>na.fill()</code> or <code>fillna</code> also accepts boolean and replaces nulls with booleans. In prior Spark versions, PySpark just ignores it and returns the original Dataset/DataFrame.</li>
            <li>Since Spark 2.3, when either broadcast hash join or broadcast nested loop join is applicable, we prefer to broadcasting the table that is explicitly specified in a broadcast hint. For details, see the section <a href="#broadcast-hint-for-sql-queries">Broadcast Hint</a> and <a href="https://issues.apache.org/jira/browse/SPARK-22489">SPARK-22489</a>.</li>
            <li>Since Spark 2.3, when all inputs are binary, <code>functions.concat()</code> returns an output as binary. Otherwise, it returns as a string. Until Spark 2.3, it always returns as a string despite of input types. To keep the old behavior, set <code>spark.sql.function.concatBinaryAsString</code> to <code>true</code>.</li>
            <li>
                <p>Since Spark 2.3, when all inputs are binary, SQL <code>elt()</code> returns an output as binary. Otherwise, it returns as a string. Until Spark 2.3, it always returns as a string despite of input types. To keep the old behavior, set <code>spark.sql.function.eltOutputAsString</code> to <code>true</code>.</p>
            </li>
            <li>Since Spark 2.3, by default arithmetic operations between decimals return a rounded value if an exact representation is not possible (instead of returning NULL). This is compliant with SQL ANSI 2011 specification and Hive&#8217;s new behavior introduced in Hive 2.2 (HIVE-15331). This involves the following changes
                <ul>
                    <li>The rules to determine the result type of an arithmetic operation have been updated. In particular, if the precision / scale needed are out of the range of available values, the scale is reduced up to 6, in order to prevent the truncation of the integer part of the decimals. All the arithmetic operations are affected by the change, ie. addition (<code>+</code>), subtraction (<code>-</code>), multiplication (<code>*</code>), division (<code>/</code>), remainder (<code>%</code>) and positive module (<code>pmod</code>).</li>
                    <li>Literal values used in SQL operations are converted to DECIMAL with the exact precision and scale needed by them.</li>
                    <li>The configuration <code>spark.sql.decimalOperations.allowPrecisionLoss</code> has been introduced. It defaults to <code>true</code>, which means the new behavior described here; if set to <code>false</code>, Spark uses previous rules, ie. it doesn&#8217;t adjust the needed scale to represent the values and it returns NULL if an exact representation of the value is not possible.</li>
                </ul>
            </li>
            <li>In PySpark, <code>df.replace</code> does not allow to omit <code>value</code> when <code>to_replace</code> is not a dictionary. Previously, <code>value</code> could be omitted in the other cases and had <code>None</code> by default, which is counterintuitive and error prone.</li>
        </ul>

        <h2 id="upgrading-from-spark-sql-21-to-22">Upgrading From Spark SQL 2.1 to 2.2</h2>

        <ul>
            <li>
                <p>Spark 2.1.1 introduced a new configuration key: <code>spark.sql.hive.caseSensitiveInferenceMode</code>. It had a default setting of <code>NEVER_INFER</code>, which kept behavior identical to 2.1.0. However, Spark 2.4.3 changes this setting&#8217;s default value to <code>INFER_AND_SAVE</code> to restore compatibility with reading Hive metastore tables whose underlying file schema have mixed-case column names. With the <code>INFER_AND_SAVE</code> configuration value, on first access Spark will perform schema inference on any Hive metastore table for which it has not already saved an inferred schema. Note that schema inference can be a very time consuming operation for tables with thousands of partitions. If compatibility with mixed-case column names is not a concern, you can safely set <code>spark.sql.hive.caseSensitiveInferenceMode</code> to <code>NEVER_INFER</code> to avoid the initial overhead of schema inference. Note that with the new default <code>INFER_AND_SAVE</code> setting, the results of the schema inference are saved as a metastore key for future use. Therefore, the initial schema inference occurs only at a table&#8217;s first access.</p>
            </li>
            <li>
                <p>Since Spark 2.2.1 and 2.3.0, the schema is always inferred at runtime when the data source tables have the columns that exist in both partition schema and data schema. The inferred schema does not have the partitioned columns. When reading the table, Spark respects the partition values of these overlapping columns instead of the values stored in the data source files. In 2.4.3 and 2.1.x release, the inferred schema is partitioned but the data of the table is invisible to users (i.e., the result set is empty).</p>
            </li>
        </ul>

        <h2 id="upgrading-from-spark-sql-20-to-21">Upgrading From Spark SQL 2.0 to 2.1</h2>

        <ul>
            <li>Datasource tables now store partition metadata in the Hive metastore. This means that Hive DDLs such as <code>ALTER TABLE PARTITION ... SET LOCATION</code> are now available for tables created with the Datasource API.
                <ul>
                    <li>Legacy datasource tables can be migrated to this format via the <code>MSCK REPAIR TABLE</code> command. Migrating legacy tables is recommended to take advantage of Hive DDL support and improved planning performance.</li>
                    <li>To determine if a table has been migrated, look for the <code>PartitionProvider: Catalog</code> attribute when issuing <code>DESCRIBE FORMATTED</code> on the table.</li>
                </ul>
            </li>
            <li>Changes to <code>INSERT OVERWRITE TABLE ... PARTITION ...</code> behavior for Datasource tables.
                <ul>
                    <li>In prior Spark versions <code>INSERT OVERWRITE</code> overwrote the entire Datasource table, even when given a partition specification. Now only partitions matching the specification are overwritten.</li>
                    <li>Note that this still differs from the behavior of Hive tables, which is to overwrite only partitions overlapping with newly inserted data.</li>
                </ul>
            </li>
        </ul>

        <h2 id="upgrading-from-spark-sql-16-to-20">Upgrading From Spark SQL 1.6 to 2.0</h2>

        <ul>
            <li>
                <p><code>SparkSession</code> is now the new entry point of Spark that replaces the old <code>SQLContext</code> and
                    <code>HiveContext</code>. Note that the old SQLContext and HiveContext are kept for backward compatibility. A new <code>catalog</code> interface is accessible from <code>SparkSession</code> - existing API on databases and tables access such as <code>listTables</code>, <code>createExternalTable</code>, <code>dropTempView</code>, <code>cacheTable</code> are moved here.</p>
            </li>
            <li>
                <p>Dataset API and DataFrame API are unified. In Scala, <code>DataFrame</code> becomes a type alias for
                    <code>Dataset[Row]</code>, while Java API users must replace <code>DataFrame</code> with <code>Dataset&lt;Row&gt;</code>. Both the typed
                    transformations (e.g., <code>map</code>, <code>filter</code>, and <code>groupByKey</code>) and untyped transformations (e.g.,
                    <code>select</code> and <code>groupBy</code>) are available on the Dataset class. Since compile-time type-safety in
                    Python and R is not a language feature, the concept of Dataset does not apply to these languages’
                    APIs. Instead, <code>DataFrame</code> remains the primary programming abstraction, which is analogous to the
                    single-node data frame notion in these languages.</p>
            </li>
            <li>Dataset and DataFrame API <code>unionAll</code> has been deprecated and replaced by <code>union</code></li>
            <li>Dataset and DataFrame API <code>explode</code> has been deprecated, alternatively, use <code>functions.explode()</code> with <code>select</code> or <code>flatMap</code></li>
            <li>
                <p>Dataset and DataFrame API <code>registerTempTable</code> has been deprecated and replaced by <code>createOrReplaceTempView</code></p>
            </li>
            <li>Changes to <code>CREATE TABLE ... LOCATION</code> behavior for Hive tables.
                <ul>
                    <li>From Spark 2.0, <code>CREATE TABLE ... LOCATION</code> is equivalent to <code>CREATE EXTERNAL TABLE ... LOCATION</code>
                        in order to prevent accidental dropping the existing data in the user-provided locations.
                        That means, a Hive table created in Spark SQL with the user-specified location is always a Hive external table.
                        Dropping external tables will not remove the data. Users are not allowed to specify the location for Hive managed tables.
                        Note that this is different from the Hive behavior.</li>
                    <li>As a result, <code>DROP TABLE</code> statements on those tables will not remove the data.</li>
                </ul>
            </li>
            <li><code>spark.sql.parquet.cacheMetadata</code> is no longer used.
                See <a href="https://issues.apache.org/jira/browse/SPARK-13664">SPARK-13664</a> for details.</li>
        </ul>

        <h2 id="upgrading-from-spark-sql-15-to-16">Upgrading From Spark SQL 1.5 to 1.6</h2>

        <ul>
            <li>From Spark 1.6, by default the Thrift server runs in multi-session mode. Which means each JDBC/ODBC
                connection owns a copy of their own SQL configuration and temporary function registry. Cached
                tables are still shared though. If you prefer to run the Thrift server in the old single-session
                mode, please set option <code>spark.sql.hive.thriftServer.singleSession</code> to <code>true</code>. You may either add
                this option to <code>spark-defaults.conf</code>, or pass it to <code>start-thriftserver.sh</code> via <code>--conf</code>:</li>
        </ul>

        <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>   ./sbin/start-thriftserver.sh <span class="se">\</span>
     --conf spark.sql.hive.thriftServer.singleSession<span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
     ...
   </code></pre></figure>

        <ul>
            <li>
                <p>Since 1.6.1, withColumn method in sparkR supports adding a new column to or replacing existing columns
                    of the same name of a DataFrame.</p>
            </li>
            <li>
                <p>From Spark 1.6, LongType casts to TimestampType expect seconds instead of microseconds. This
                    change was made to match the behavior of Hive 1.2 for more consistent type casting to TimestampType
                    from numeric types. See <a href="https://issues.apache.org/jira/browse/SPARK-11724">SPARK-11724</a> for
                    details.</p>
            </li>
        </ul>

        <h2 id="upgrading-from-spark-sql-14-to-15">Upgrading From Spark SQL 1.4 to 1.5</h2>

        <ul>
            <li>Optimized execution using manually managed memory (Tungsten) is now enabled by default, along with
                code generation for expression evaluation. These features can both be disabled by setting
                <code>spark.sql.tungsten.enabled</code> to <code>false</code>.</li>
            <li>Parquet schema merging is no longer enabled by default. It can be re-enabled by setting
                <code>spark.sql.parquet.mergeSchema</code> to <code>true</code>.</li>
            <li>Resolution of strings to columns in python now supports using dots (<code>.</code>) to qualify the column or
                access nested values. For example <code>df['table.column.nestedField']</code>. However, this means that if
                your column name contains any dots you must now escape them using backticks (e.g., <code>table.`column.with.dots`.nested</code>).</li>
            <li>In-memory columnar storage partition pruning is on by default. It can be disabled by setting
                <code>spark.sql.inMemoryColumnarStorage.partitionPruning</code> to <code>false</code>.</li>
            <li>Unlimited precision decimal columns are no longer supported, instead Spark SQL enforces a maximum
                precision of 38. When inferring schema from <code>BigDecimal</code> objects, a precision of (38, 18) is now
                used. When no precision is specified in DDL then the default remains <code>Decimal(10, 0)</code>.</li>
            <li>Timestamps are now stored at a precision of 1us, rather than 1ns</li>
            <li>In the <code>sql</code> dialect, floating point numbers are now parsed as decimal. HiveQL parsing remains
                unchanged.</li>
            <li>The canonical name of SQL/DataFrame functions are now lower case (e.g., sum vs SUM).</li>
            <li>JSON data source will not automatically load new files that are created by other applications
                (i.e. files that are not inserted to the dataset through Spark SQL).
                For a JSON persistent table (i.e. the metadata of the table is stored in Hive Metastore),
                users can use <code>REFRESH TABLE</code> SQL command or <code>HiveContext</code>&#8217;s <code>refreshTable</code> method
                to include those new files to the table. For a DataFrame representing a JSON dataset, users need to recreate
                the DataFrame and the new DataFrame will include new files.</li>
            <li>DataFrame.withColumn method in pySpark supports adding a new column or replacing existing columns of the same name.</li>
        </ul>

        <h2 id="upgrading-from-spark-sql-13-to-14">Upgrading from Spark SQL 1.3 to 1.4</h2>

        <h4 id="dataframe-data-readerwriter-interface">DataFrame data reader/writer interface</h4>

        <p>Based on user feedback, we created a new, more fluid API for reading data in (<code>SQLContext.read</code>)
            and writing data out (<code>DataFrame.write</code>),
            and deprecated the old APIs (e.g., <code>SQLContext.parquetFile</code>, <code>SQLContext.jsonFile</code>).</p>

        <p>See the API docs for <code>SQLContext.read</code> (
            <a href="api/scala/index.html#org.apache.spark.sql.SQLContext@read:DataFrameReader">Scala</a>,
            <a href="api/java/org/apache/spark/sql/SQLContext.html#read()">Java</a>,
            <a href="api/python/pyspark.sql.html#pyspark.sql.SQLContext.read">Python</a>
            ) and <code>DataFrame.write</code> (
            <a href="api/scala/index.html#org.apache.spark.sql.DataFrame@write:DataFrameWriter">Scala</a>,
            <a href="api/java/org/apache/spark/sql/DataFrame.html#write()">Java</a>,
            <a href="api/python/pyspark.sql.html#pyspark.sql.DataFrame.write">Python</a>
            ) more information.</p>

        <h4 id="dataframegroupby-retains-grouping-columns">DataFrame.groupBy retains grouping columns</h4>

        <p>Based on user feedback, we changed the default behavior of <code>DataFrame.groupBy().agg()</code> to retain the
            grouping columns in the resulting <code>DataFrame</code>. To keep the behavior in 1.3, set <code>spark.sql.retainGroupColumns</code> to <code>false</code>.</p>

        <div class="codetabs">
            <div data-lang="scala">

                <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="c1">// In 1.3.x, in order for the grouping column &quot;department&quot; to show up,</span>
<span class="c1">// it must be included explicitly as part of the agg function call.</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="s">&quot;department&quot;</span><span class="o">).</span><span class="n">agg</span><span class="o">(</span><span class="n">$</span><span class="s">&quot;department&quot;</span><span class="o">,</span> <span class="n">max</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">),</span> <span class="n">sum</span><span class="o">(</span><span class="s">&quot;expense&quot;</span><span class="o">))</span>

<span class="c1">// In 1.4+, grouping column &quot;department&quot; is included automatically.</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="s">&quot;department&quot;</span><span class="o">).</span><span class="n">agg</span><span class="o">(</span><span class="n">max</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">),</span> <span class="n">sum</span><span class="o">(</span><span class="s">&quot;expense&quot;</span><span class="o">))</span>

<span class="c1">// Revert to 1.3 behavior (not retaining grouping column) by:</span>
<span class="n">sqlContext</span><span class="o">.</span><span class="n">setConf</span><span class="o">(</span><span class="s">&quot;spark.sql.retainGroupColumns&quot;</span><span class="o">,</span> <span class="s">&quot;false&quot;</span><span class="o">)</span></code></pre></figure>

            </div>

            <div data-lang="java">

                <figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="c1">// In 1.3.x, in order for the grouping column &quot;department&quot; to show up,</span>
<span class="c1">// it must be included explicitly as part of the agg function call.</span>
<span class="n">df</span><span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="s">&quot;department&quot;</span><span class="o">).</span><span class="na">agg</span><span class="o">(</span><span class="n">col</span><span class="o">(</span><span class="s">&quot;department&quot;</span><span class="o">),</span> <span class="n">max</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">),</span> <span class="n">sum</span><span class="o">(</span><span class="s">&quot;expense&quot;</span><span class="o">));</span>

<span class="c1">// In 1.4+, grouping column &quot;department&quot; is included automatically.</span>
<span class="n">df</span><span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="s">&quot;department&quot;</span><span class="o">).</span><span class="na">agg</span><span class="o">(</span><span class="n">max</span><span class="o">(</span><span class="s">&quot;age&quot;</span><span class="o">),</span> <span class="n">sum</span><span class="o">(</span><span class="s">&quot;expense&quot;</span><span class="o">));</span>

<span class="c1">// Revert to 1.3 behavior (not retaining grouping column) by:</span>
<span class="n">sqlContext</span><span class="o">.</span><span class="na">setConf</span><span class="o">(</span><span class="s">&quot;spark.sql.retainGroupColumns&quot;</span><span class="o">,</span> <span class="s">&quot;false&quot;</span><span class="o">);</span></code></pre></figure>

            </div>

            <div data-lang="python">

                <figure class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="kn">import</span> <span class="nn">pyspark.sql.functions</span> <span class="kn">as</span> <span class="nn">func</span>

<span class="c1"># In 1.3.x, in order for the grouping column &quot;department&quot; to show up,</span>
<span class="c1"># it must be included explicitly as part of the agg function call.</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&quot;department&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;department&quot;</span><span class="p">],</span> <span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">),</span> <span class="n">func</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s2">&quot;expense&quot;</span><span class="p">))</span>

<span class="c1"># In 1.4+, grouping column &quot;department&quot; is included automatically.</span>
<span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&quot;department&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="s2">&quot;age&quot;</span><span class="p">),</span> <span class="n">func</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s2">&quot;expense&quot;</span><span class="p">))</span>

<span class="c1"># Revert to 1.3.x behavior (not retaining grouping column) by:</span>
<span class="n">sqlContext</span><span class="o">.</span><span class="n">setConf</span><span class="p">(</span><span class="s2">&quot;spark.sql.retainGroupColumns&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">)</span></code></pre></figure>

            </div>

        </div>

        <h4 id="behavior-change-on-dataframewithcolumn">Behavior change on DataFrame.withColumn</h4>

        <p>Prior to 1.4, DataFrame.withColumn() supports adding a column only. The column will always be added
            as a new column with its specified name in the result DataFrame even if there may be any existing
            columns of the same name. Since 1.4, DataFrame.withColumn() supports adding a column of a different
            name from names of all existing columns or replacing existing columns of the same name.</p>

        <p>Note that this change is only for Scala API, not for PySpark and SparkR.</p>

        <h2 id="upgrading-from-spark-sql-10-12-to-13">Upgrading from Spark SQL 1.0-1.2 to 1.3</h2>

        <p>In Spark 1.3 we removed the &#8220;Alpha&#8221; label from Spark SQL and as part of this did a cleanup of the
            available APIs. From Spark 1.3 onwards, Spark SQL will provide binary compatibility with other
            releases in the 1.X series. This compatibility guarantee excludes APIs that are explicitly marked
            as unstable (i.e., DeveloperAPI or Experimental).</p>

        <h4 id="rename-of-schemardd-to-dataframe">Rename of SchemaRDD to DataFrame</h4>

        <p>The largest change that users will notice when upgrading to Spark SQL 1.3 is that <code>SchemaRDD</code> has
            been renamed to <code>DataFrame</code>. This is primarily because DataFrames no longer inherit from RDD
            directly, but instead provide most of the functionality that RDDs provide though their own
            implementation. DataFrames can still be converted to RDDs by calling the <code>.rdd</code> method.</p>

        <p>In Scala there is a type alias from <code>SchemaRDD</code> to <code>DataFrame</code> to provide source compatibility for
            some use cases. It is still recommended that users update their code to use <code>DataFrame</code> instead.
            Java and Python users will need to update their code.</p>

        <h4 id="unification-of-the-java-and-scala-apis">Unification of the Java and Scala APIs</h4>

        <p>Prior to Spark 1.3 there were separate Java compatible classes (<code>JavaSQLContext</code> and <code>JavaSchemaRDD</code>)
            that mirrored the Scala API. In Spark 1.3 the Java API and Scala API have been unified. Users
            of either language should use <code>SQLContext</code> and <code>DataFrame</code>. In general these classes try to
            use types that are usable from both languages (i.e. <code>Array</code> instead of language specific collections).
            In some cases where no common type exists (e.g., for passing in closures or Maps) function overloading
            is used instead.</p>

        <p>Additionally the Java specific types API has been removed. Users of both Scala and Java should
            use the classes present in <code>org.apache.spark.sql.types</code> to describe schema programmatically.</p>

        <h4 id="isolation-of-implicit-conversions-and-removal-of-dsl-package-scala-only">Isolation of Implicit Conversions and Removal of dsl Package (Scala-only)</h4>

        <p>Many of the code examples prior to Spark 1.3 started with <code>import sqlContext._</code>, which brought
            all of the functions from sqlContext into scope. In Spark 1.3 we have isolated the implicit
            conversions for converting <code>RDD</code>s into <code>DataFrame</code>s into an object inside of the <code>SQLContext</code>.
            Users should now write <code>import sqlContext.implicits._</code>.</p>

        <p>Additionally, the implicit conversions now only augment RDDs that are composed of <code>Product</code>s (i.e.,
            case classes or tuples) with a method <code>toDF</code>, instead of applying automatically.</p>

        <p>When using function inside of the DSL (now replaced with the <code>DataFrame</code> API) users used to import
            <code>org.apache.spark.sql.catalyst.dsl</code>. Instead the public dataframe functions API should be used:
            <code>import org.apache.spark.sql.functions._</code>.</p>

        <h4 id="removal-of-the-type-aliases-in-orgapachesparksql-for-datatype-scala-only">Removal of the type aliases in org.apache.spark.sql for DataType (Scala-only)</h4>

        <p>Spark 1.3 removes the type aliases that were present in the base sql package for <code>DataType</code>. Users
            should instead import the classes in <code>org.apache.spark.sql.types</code></p>

        <h4 id="udf-registration-moved-to-sqlcontextudf-java--scala">UDF Registration Moved to <code>sqlContext.udf</code> (Java &amp; Scala)</h4>

        <p>Functions that are used to register UDFs, either for use in the DataFrame DSL or SQL, have been
            moved into the udf object in <code>SQLContext</code>.</p>

        <div class="codetabs">
            <div data-lang="scala">

                <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span></span><span class="n">sqlContext</span><span class="o">.</span><span class="n">udf</span><span class="o">.</span><span class="n">register</span><span class="o">(</span><span class="s">&quot;strLen&quot;</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">())</span></code></pre></figure>

            </div>

            <div data-lang="java">

                <figure class="highlight"><pre><code class="language-java" data-lang="java"><span></span><span class="n">sqlContext</span><span class="o">.</span><span class="na">udf</span><span class="o">().</span><span class="na">register</span><span class="o">(</span><span class="s">&quot;strLen&quot;</span><span class="o">,</span> <span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">DataTypes</span><span class="o">.</span><span class="na">IntegerType</span><span class="o">);</span></code></pre></figure>

            </div>

        </div>

        <p>Python UDF registration is unchanged.</p>

        <h4 id="python-datatypes-no-longer-singletons">Python DataTypes No Longer Singletons</h4>

        <p>When using DataTypes in Python you will need to construct them (i.e. <code>StringType()</code>) instead of
            referencing a singleton.</p>

        <h2 id="compatibility-with-apache-hive">Compatibility with Apache Hive</h2>

        <p>Spark SQL is designed to be compatible with the Hive Metastore, SerDes and UDFs.
            Currently Hive SerDes and UDFs are based on Hive 1.2.1,
            and Spark SQL can be connected to different versions of Hive Metastore
            (from 0.12.0 to 2.1.1. Also see <a href="#interacting-with-different-versions-of-hive-metastore">Interacting with Different Versions of Hive Metastore</a>).</p>

        <h4 id="deploying-in-existing-hive-warehouses">Deploying in Existing Hive Warehouses</h4>

        <p>The Spark SQL Thrift JDBC server is designed to be &#8220;out of the box&#8221; compatible with existing Hive
            installations. You do not need to modify your existing Hive Metastore or change the data placement
            or partitioning of your tables.</p>

        <h3 id="supported-hive-features">Supported Hive Features</h3>

        <p>Spark SQL supports the vast majority of Hive features, such as:</p>

        <ul>
            <li>Hive query statements, including:
                <ul>
                    <li><code>SELECT</code></li>
                    <li><code>GROUP BY</code></li>
                    <li><code>ORDER BY</code></li>
                    <li><code>CLUSTER BY</code></li>
                    <li><code>SORT BY</code></li>
                </ul>
            </li>
            <li>All Hive operators, including:
                <ul>
                    <li>Relational operators (<code>=</code>, <code>⇔</code>, <code>==</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, etc)</li>
                    <li>Arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, etc)</li>
                    <li>Logical operators (<code>AND</code>, <code>&amp;&amp;</code>, <code>OR</code>, <code>||</code>, etc)</li>
                    <li>Complex type constructors</li>
                    <li>Mathematical functions (<code>sign</code>, <code>ln</code>, <code>cos</code>, etc)</li>
                    <li>String functions (<code>instr</code>, <code>length</code>, <code>printf</code>, etc)</li>
                </ul>
            </li>
            <li>User defined functions (UDF)</li>
            <li>User defined aggregation functions (UDAF)</li>
            <li>User defined serialization formats (SerDes)</li>
            <li>Window functions</li>
            <li>Joins
                <ul>
                    <li><code>JOIN</code></li>
                    <li><code>{LEFT|RIGHT|FULL} OUTER JOIN</code></li>
                    <li><code>LEFT SEMI JOIN</code></li>
                    <li><code>CROSS JOIN</code></li>
                </ul>
            </li>
            <li>Unions</li>
            <li>Sub-queries
                <ul>
                    <li><code>SELECT col FROM ( SELECT a + b AS col from t1) t2</code></li>
                </ul>
            </li>
            <li>Sampling</li>
            <li>Explain</li>
            <li>Partitioned tables including dynamic partition insertion</li>
            <li>View</li>
            <li>All Hive DDL Functions, including:
                <ul>
                    <li><code>CREATE TABLE</code></li>
                    <li><code>CREATE TABLE AS SELECT</code></li>
                    <li><code>ALTER TABLE</code></li>
                </ul>
            </li>
            <li>Most Hive Data types, including:
                <ul>
                    <li><code>TINYINT</code></li>
                    <li><code>SMALLINT</code></li>
                    <li><code>INT</code></li>
                    <li><code>BIGINT</code></li>
                    <li><code>BOOLEAN</code></li>
                    <li><code>FLOAT</code></li>
                    <li><code>DOUBLE</code></li>
                    <li><code>STRING</code></li>
                    <li><code>BINARY</code></li>
                    <li><code>TIMESTAMP</code></li>
                    <li><code>DATE</code></li>
                    <li><code>ARRAY&lt;&gt;</code></li>
                    <li><code>MAP&lt;&gt;</code></li>
                    <li><code>STRUCT&lt;&gt;</code></li>
                </ul>
            </li>
        </ul>

        <h3 id="unsupported-hive-functionality">Unsupported Hive Functionality</h3>

        <p>Below is a list of Hive features that we don&#8217;t support yet. Most of these features are rarely used
            in Hive deployments.</p>

        <p><strong>Major Hive Features</strong></p>

        <ul>
            <li>Tables with buckets: bucket is the hash partitioning within a Hive table partition. Spark SQL
                doesn&#8217;t support buckets yet.</li>
        </ul>

        <p><strong>Esoteric Hive Features</strong></p>

        <ul>
            <li><code>UNION</code> type</li>
            <li>Unique join</li>
            <li>Column statistics collecting: Spark SQL does not piggyback scans to collect column statistics at
                the moment and only supports populating the sizeInBytes field of the hive metastore.</li>
        </ul>

        <p><strong>Hive Input/Output Formats</strong></p>

        <ul>
            <li>File format for CLI: For results showing back to the CLI, Spark SQL only supports TextOutputFormat.</li>
            <li>Hadoop archive</li>
        </ul>

        <p><strong>Hive Optimizations</strong></p>

        <p>A handful of Hive optimizations are not yet included in Spark. Some of these (such as indexes) are
            less important due to Spark SQL&#8217;s in-memory computational model. Others are slotted for future
            releases of Spark SQL.</p>

        <ul>
            <li>Block level bitmap indexes and virtual columns (used to build indexes)</li>
            <li>Automatically determine the number of reducers for joins and groupbys: Currently in Spark SQL, you
                need to control the degree of parallelism post-shuffle using &#8220;<code>SET spark.sql.shuffle.partitions=[num_tasks];</code>&#8221;.</li>
            <li>Meta-data only query: For queries that can be answered by using only meta data, Spark SQL still
                launches tasks to compute the result.</li>
            <li>Skew data flag: Spark SQL does not follow the skew data flags in Hive.</li>
            <li><code>STREAMTABLE</code> hint in join: Spark SQL does not follow the <code>STREAMTABLE</code> hint.</li>
            <li>Merge multiple small files for query results: if the result output contains multiple small files,
                Hive can optionally merge the small files into fewer large files to avoid overflowing the HDFS
                metadata. Spark SQL does not support that.</li>
        </ul>

        <p><strong>Hive UDF/UDTF/UDAF</strong></p>

        <p>Not all the APIs of the Hive UDF/UDTF/UDAF are supported by Spark SQL. Below are the unsupported APIs:</p>

        <ul>
            <li><code>getRequiredJars</code> and <code>getRequiredFiles</code> (<code>UDF</code> and <code>GenericUDF</code>) are functions to automatically
                include additional resources required by this UDF.</li>
            <li><code>initialize(StructObjectInspector)</code> in <code>GenericUDTF</code> is not supported yet. Spark SQL currently uses
                a deprecated interface <code>initialize(ObjectInspector[])</code> only.</li>
            <li><code>configure</code> (<code>GenericUDF</code>, <code>GenericUDTF</code>, and <code>GenericUDAFEvaluator</code>) is a function to initialize
                functions with <code>MapredContext</code>, which is inapplicable to Spark.</li>
            <li><code>close</code> (<code>GenericUDF</code> and <code>GenericUDAFEvaluator</code>) is a function to release associated resources.
                Spark SQL does not call this function when tasks finish.</li>
            <li><code>reset</code> (<code>GenericUDAFEvaluator</code>) is a function to re-initialize aggregation for reusing the same aggregation.
                Spark SQL currently does not support the reuse of aggregation.</li>
            <li><code>getWindowingEvaluator</code> (<code>GenericUDAFEvaluator</code>) is a function to optimize aggregation by evaluating
                an aggregate over a fixed window.</li>
        </ul>

        <h3 id="incompatible-hive-udf">Incompatible Hive UDF</h3>

        <p>Below are the scenarios in which Hive and Spark generate different results:</p>

        <ul>
            <li><code>SQRT(n)</code> If n &lt; 0, Hive returns null, Spark SQL returns NaN.</li>
            <li><code>ACOS(n)</code> If n &lt; -1 or n &gt; 1, Hive returns null, Spark SQL returns NaN.</li>
            <li><code>ASIN(n)</code> If n &lt; -1 or n &gt; 1, Hive returns null, Spark SQL returns NaN.</li>
        </ul>

        <h1 id="reference">Reference</h1>

        <h2 id="data-types">Data Types</h2>

        <p>Spark SQL and DataFrames support the following data types:</p>

        <ul>
            <li>Numeric types
                <ul>
                    <li><code>ByteType</code>: Represents 1-byte signed integer numbers.
                        The range of numbers is from <code>-128</code> to <code>127</code>.</li>
                    <li><code>ShortType</code>: Represents 2-byte signed integer numbers.
                        The range of numbers is from <code>-32768</code> to <code>32767</code>.</li>
                    <li><code>IntegerType</code>: Represents 4-byte signed integer numbers.
                        The range of numbers is from <code>-2147483648</code> to <code>2147483647</code>.</li>
                    <li><code>LongType</code>: Represents 8-byte signed integer numbers.
                        The range of numbers is from <code>-9223372036854775808</code> to <code>9223372036854775807</code>.</li>
                    <li><code>FloatType</code>: Represents 4-byte single-precision floating point numbers.</li>
                    <li><code>DoubleType</code>: Represents 8-byte double-precision floating point numbers.</li>
                    <li><code>DecimalType</code>: Represents arbitrary-precision signed decimal numbers. Backed internally by <code>java.math.BigDecimal</code>. A <code>BigDecimal</code> consists of an arbitrary precision integer unscaled value and a 32-bit integer scale.</li>
                </ul>
            </li>
            <li>String type
                <ul>
                    <li><code>StringType</code>: Represents character string values.</li>
                </ul>
            </li>
            <li>Binary type
                <ul>
                    <li><code>BinaryType</code>: Represents byte sequence values.</li>
                </ul>
            </li>
            <li>Boolean type
                <ul>
                    <li><code>BooleanType</code>: Represents boolean values.</li>
                </ul>
            </li>
            <li>Datetime type
                <ul>
                    <li><code>TimestampType</code>: Represents values comprising values of fields year, month, day,
                        hour, minute, and second.</li>
                    <li><code>DateType</code>: Represents values comprising values of fields year, month, day.</li>
                </ul>
            </li>
            <li>Complex types
                <ul>
                    <li><code>ArrayType(elementType, containsNull)</code>: Represents values comprising a sequence of
                        elements with the type of <code>elementType</code>. <code>containsNull</code> is used to indicate if
                        elements in a <code>ArrayType</code> value can have <code>null</code> values.</li>
                    <li><code>MapType(keyType, valueType, valueContainsNull)</code>:
                        Represents values comprising a set of key-value pairs. The data type of keys are
                        described by <code>keyType</code> and the data type of values are described by <code>valueType</code>.
                        For a <code>MapType</code> value, keys are not allowed to have <code>null</code> values. <code>valueContainsNull</code>
                        is used to indicate if values of a <code>MapType</code> value can have <code>null</code> values.</li>
                    <li><code>StructType(fields)</code>: Represents values with the structure described by
                        a sequence of <code>StructField</code>s (<code>fields</code>).
                        <ul>
                            <li><code>StructField(name, dataType, nullable)</code>: Represents a field in a <code>StructType</code>.
                                The name of a field is indicated by <code>name</code>. The data type of a field is indicated
                                by <code>dataType</code>. <code>nullable</code> is used to indicate if values of this fields can have
                                <code>null</code> values.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <div class="codetabs">
            <div data-lang="scala">

                <p>All data types of Spark SQL are located in the package <code>org.apache.spark.sql.types</code>.
                    You can access them by doing</p>

                <div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.sql.types._</span>
</pre></div>
                <div><small>Find full example code at "examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala" in the Spark repo.</small></div>

                <table class="table">
                    <tr>
                        <th style="width:20%">Data type</th>
                        <th style="width:40%">Value type in Scala</th>
                        <th>API to access or create a data type</th></tr>
                    <tr>
                        <td> <b>ByteType</b> </td>
                        <td> Byte </td>
                        <td>
                            ByteType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ShortType</b> </td>
                        <td> Short </td>
                        <td>
                            ShortType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>IntegerType</b> </td>
                        <td> Int </td>
                        <td>
                            IntegerType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>LongType</b> </td>
                        <td> Long </td>
                        <td>
                            LongType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>FloatType</b> </td>
                        <td> Float </td>
                        <td>
                            FloatType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DoubleType</b> </td>
                        <td> Double </td>
                        <td>
                            DoubleType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DecimalType</b> </td>
                        <td> java.math.BigDecimal </td>
                        <td>
                            DecimalType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StringType</b> </td>
                        <td> String </td>
                        <td>
                            StringType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BinaryType</b> </td>
                        <td> Array[Byte] </td>
                        <td>
                            BinaryType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BooleanType</b> </td>
                        <td> Boolean </td>
                        <td>
                            BooleanType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>TimestampType</b> </td>
                        <td> java.sql.Timestamp </td>
                        <td>
                            TimestampType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DateType</b> </td>
                        <td> java.sql.Date </td>
                        <td>
                            DateType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ArrayType</b> </td>
                        <td> scala.collection.Seq </td>
                        <td>
                            ArrayType(<i>elementType</i>, [<i>containsNull</i>])<br />
                            <b>Note:</b> The default value of <i>containsNull</i> is <i>true</i>.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>MapType</b> </td>
                        <td> scala.collection.Map </td>
                        <td>
                            MapType(<i>keyType</i>, <i>valueType</i>, [<i>valueContainsNull</i>])<br />
                            <b>Note:</b> The default value of <i>valueContainsNull</i> is <i>true</i>.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructType</b> </td>
                        <td> org.apache.spark.sql.Row </td>
                        <td>
                            StructType(<i>fields</i>)<br />
                            <b>Note:</b> <i>fields</i> is a Seq of StructFields. Also, two fields with the same
                            name are not allowed.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructField</b> </td>
                        <td> The value type in Scala of the data type of this field
                            (For example, Int for a StructField with the data type IntegerType) </td>
                        <td>
                            StructField(<i>name</i>, <i>dataType</i>, [<i>nullable</i>])<br />
                            <b>Note:</b> The default value of <i>nullable</i> is <i>true</i>.
                        </td>
                    </tr>
                </table>

            </div>

            <div data-lang="java">

                <p>All data types of Spark SQL are located in the package of
                    <code>org.apache.spark.sql.types</code>. To access or create a data type,
                    please use factory methods provided in
                    <code>org.apache.spark.sql.types.DataTypes</code>.</p>

                <table class="table">
                    <tr>
                        <th style="width:20%">Data type</th>
                        <th style="width:40%">Value type in Java</th>
                        <th>API to access or create a data type</th></tr>
                    <tr>
                        <td> <b>ByteType</b> </td>
                        <td> byte or Byte </td>
                        <td>
                            DataTypes.ByteType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ShortType</b> </td>
                        <td> short or Short </td>
                        <td>
                            DataTypes.ShortType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>IntegerType</b> </td>
                        <td> int or Integer </td>
                        <td>
                            DataTypes.IntegerType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>LongType</b> </td>
                        <td> long or Long </td>
                        <td>
                            DataTypes.LongType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>FloatType</b> </td>
                        <td> float or Float </td>
                        <td>
                            DataTypes.FloatType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DoubleType</b> </td>
                        <td> double or Double </td>
                        <td>
                            DataTypes.DoubleType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DecimalType</b> </td>
                        <td> java.math.BigDecimal </td>
                        <td>
                            DataTypes.createDecimalType()<br />
                            DataTypes.createDecimalType(<i>precision</i>, <i>scale</i>).
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StringType</b> </td>
                        <td> String </td>
                        <td>
                            DataTypes.StringType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BinaryType</b> </td>
                        <td> byte[] </td>
                        <td>
                            DataTypes.BinaryType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BooleanType</b> </td>
                        <td> boolean or Boolean </td>
                        <td>
                            DataTypes.BooleanType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>TimestampType</b> </td>
                        <td> java.sql.Timestamp </td>
                        <td>
                            DataTypes.TimestampType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DateType</b> </td>
                        <td> java.sql.Date </td>
                        <td>
                            DataTypes.DateType
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ArrayType</b> </td>
                        <td> java.util.List </td>
                        <td>
                            DataTypes.createArrayType(<i>elementType</i>)<br />
                            <b>Note:</b> The value of <i>containsNull</i> will be <i>true</i><br />
                            DataTypes.createArrayType(<i>elementType</i>, <i>containsNull</i>).
                        </td>
                    </tr>
                    <tr>
                        <td> <b>MapType</b> </td>
                        <td> java.util.Map </td>
                        <td>
                            DataTypes.createMapType(<i>keyType</i>, <i>valueType</i>)<br />
                            <b>Note:</b> The value of <i>valueContainsNull</i> will be <i>true</i>.<br />
                            DataTypes.createMapType(<i>keyType</i>, <i>valueType</i>, <i>valueContainsNull</i>)<br />
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructType</b> </td>
                        <td> org.apache.spark.sql.Row </td>
                        <td>
                            DataTypes.createStructType(<i>fields</i>)<br />
                            <b>Note:</b> <i>fields</i> is a List or an array of StructFields.
                            Also, two fields with the same name are not allowed.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructField</b> </td>
                        <td> The value type in Java of the data type of this field
                            (For example, int for a StructField with the data type IntegerType) </td>
                        <td>
                            DataTypes.createStructField(<i>name</i>, <i>dataType</i>, <i>nullable</i>)
                        </td>
                    </tr>
                </table>

            </div>

            <div data-lang="python">

                <p>All data types of Spark SQL are located in the package of <code>pyspark.sql.types</code>.
                    You can access them by doing</p>

                <figure class="highlight"><pre><code class="language-python" data-lang="python"><span></span><span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="kn">import</span> <span class="o">*</span></code></pre></figure>

                <table class="table">
                    <tr>
                        <th style="width:20%">Data type</th>
                        <th style="width:40%">Value type in Python</th>
                        <th>API to access or create a data type</th></tr>
                    <tr>
                        <td> <b>ByteType</b> </td>
                        <td>
                            int or long <br />
                            <b>Note:</b> Numbers will be converted to 1-byte signed integer numbers at runtime.
                            Please make sure that numbers are within the range of -128 to 127.
                        </td>
                        <td>
                            ByteType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ShortType</b> </td>
                        <td>
                            int or long <br />
                            <b>Note:</b> Numbers will be converted to 2-byte signed integer numbers at runtime.
                            Please make sure that numbers are within the range of -32768 to 32767.
                        </td>
                        <td>
                            ShortType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>IntegerType</b> </td>
                        <td> int or long </td>
                        <td>
                            IntegerType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>LongType</b> </td>
                        <td>
                            long <br />
                            <b>Note:</b> Numbers will be converted to 8-byte signed integer numbers at runtime.
                            Please make sure that numbers are within the range of
                            -9223372036854775808 to 9223372036854775807.
                            Otherwise, please convert data to decimal.Decimal and use DecimalType.
                        </td>
                        <td>
                            LongType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>FloatType</b> </td>
                        <td>
                            float <br />
                            <b>Note:</b> Numbers will be converted to 4-byte single-precision floating
                            point numbers at runtime.
                        </td>
                        <td>
                            FloatType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DoubleType</b> </td>
                        <td> float </td>
                        <td>
                            DoubleType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DecimalType</b> </td>
                        <td> decimal.Decimal </td>
                        <td>
                            DecimalType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StringType</b> </td>
                        <td> string </td>
                        <td>
                            StringType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BinaryType</b> </td>
                        <td> bytearray </td>
                        <td>
                            BinaryType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BooleanType</b> </td>
                        <td> bool </td>
                        <td>
                            BooleanType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>TimestampType</b> </td>
                        <td> datetime.datetime </td>
                        <td>
                            TimestampType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DateType</b> </td>
                        <td> datetime.date </td>
                        <td>
                            DateType()
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ArrayType</b> </td>
                        <td> list, tuple, or array </td>
                        <td>
                            ArrayType(<i>elementType</i>, [<i>containsNull</i>])<br />
                            <b>Note:</b> The default value of <i>containsNull</i> is <i>True</i>.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>MapType</b> </td>
                        <td> dict </td>
                        <td>
                            MapType(<i>keyType</i>, <i>valueType</i>, [<i>valueContainsNull</i>])<br />
                            <b>Note:</b> The default value of <i>valueContainsNull</i> is <i>True</i>.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructType</b> </td>
                        <td> list or tuple </td>
                        <td>
                            StructType(<i>fields</i>)<br />
                            <b>Note:</b> <i>fields</i> is a Seq of StructFields. Also, two fields with the same
                            name are not allowed.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructField</b> </td>
                        <td> The value type in Python of the data type of this field
                            (For example, Int for a StructField with the data type IntegerType) </td>
                        <td>
                            StructField(<i>name</i>, <i>dataType</i>, [<i>nullable</i>])<br />
                            <b>Note:</b> The default value of <i>nullable</i> is <i>True</i>.
                        </td>
                    </tr>
                </table>

            </div>

            <div data-lang="r">

                <table class="table">
                    <tr>
                        <th style="width:20%">Data type</th>
                        <th style="width:40%">Value type in R</th>
                        <th>API to access or create a data type</th></tr>
                    <tr>
                        <td> <b>ByteType</b> </td>
                        <td>
                            integer <br />
                            <b>Note:</b> Numbers will be converted to 1-byte signed integer numbers at runtime.
                            Please make sure that numbers are within the range of -128 to 127.
                        </td>
                        <td>
                            "byte"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ShortType</b> </td>
                        <td>
                            integer <br />
                            <b>Note:</b> Numbers will be converted to 2-byte signed integer numbers at runtime.
                            Please make sure that numbers are within the range of -32768 to 32767.
                        </td>
                        <td>
                            "short"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>IntegerType</b> </td>
                        <td> integer </td>
                        <td>
                            "integer"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>LongType</b> </td>
                        <td>
                            integer <br />
                            <b>Note:</b> Numbers will be converted to 8-byte signed integer numbers at runtime.
                            Please make sure that numbers are within the range of
                            -9223372036854775808 to 9223372036854775807.
                            Otherwise, please convert data to decimal.Decimal and use DecimalType.
                        </td>
                        <td>
                            "long"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>FloatType</b> </td>
                        <td>
                            numeric <br />
                            <b>Note:</b> Numbers will be converted to 4-byte single-precision floating
                            point numbers at runtime.
                        </td>
                        <td>
                            "float"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DoubleType</b> </td>
                        <td> numeric </td>
                        <td>
                            "double"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DecimalType</b> </td>
                        <td> Not supported </td>
                        <td>
                            Not supported
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StringType</b> </td>
                        <td> character </td>
                        <td>
                            "string"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BinaryType</b> </td>
                        <td> raw </td>
                        <td>
                            "binary"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>BooleanType</b> </td>
                        <td> logical </td>
                        <td>
                            "bool"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>TimestampType</b> </td>
                        <td> POSIXct </td>
                        <td>
                            "timestamp"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>DateType</b> </td>
                        <td> Date </td>
                        <td>
                            "date"
                        </td>
                    </tr>
                    <tr>
                        <td> <b>ArrayType</b> </td>
                        <td> vector or list </td>
                        <td>
                            list(type="array", elementType=<i>elementType</i>, containsNull=[<i>containsNull</i>])<br />
                            <b>Note:</b> The default value of <i>containsNull</i> is <i>TRUE</i>.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>MapType</b> </td>
                        <td> environment </td>
                        <td>
                            list(type="map", keyType=<i>keyType</i>, valueType=<i>valueType</i>, valueContainsNull=[<i>valueContainsNull</i>])<br />
                            <b>Note:</b> The default value of <i>valueContainsNull</i> is <i>TRUE</i>.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructType</b> </td>
                        <td> named list</td>
                        <td>
                            list(type="struct", fields=<i>fields</i>)<br />
                            <b>Note:</b> <i>fields</i> is a Seq of StructFields. Also, two fields with the same
                            name are not allowed.
                        </td>
                    </tr>
                    <tr>
                        <td> <b>StructField</b> </td>
                        <td> The value type in R of the data type of this field
                            (For example, integer for a StructField with the data type IntegerType) </td>
                        <td>
                            list(name=<i>name</i>, type=<i>dataType</i>, nullable=[<i>nullable</i>])<br />
                            <b>Note:</b> The default value of <i>nullable</i> is <i>TRUE</i>.
                        </td>
                    </tr>
                </table>

            </div>

        </div>

        <h2 id="nan-semantics">NaN Semantics</h2>

        <p>There is specially handling for not-a-number (NaN) when dealing with <code>float</code> or <code>double</code> types that
            does not exactly match standard floating point semantics.
            Specifically:</p>

        <ul>
            <li>NaN = NaN returns true.</li>
            <li>In aggregations all NaN values are grouped together.</li>
            <li>NaN is treated as a normal value in join keys.</li>
            <li>NaN values go last when in ascending order, larger than any other numeric value.</li>
        </ul>


    </div>

    <!-- /container -->
</div>

<script src="js/vendor/jquery-1.8.0.min.js"></script>
<script src="js/vendor/bootstrap.min.js"></script>
<script src="js/vendor/anchor.min.js"></script>
<script src="js/main.js"></script>
<script src="js/vendor/MathJax.js"></script>

<!-- MathJax Section -->
<script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: { equationNumbers: { autoNumber: "AMS" } }
            });
        </script>
<script>
    // Note that we load MathJax this way to work with local file (file://), HTTP and HTTPS.
    // We could use "//cdn.mathjax...", but that won't support "file://".
    (function(d, script) {
        script = d.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.onload = function(){
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ],
                    displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
                    processEscapes: true,
                    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                }
            });
        };
        script.src = ('js/vendor/MathJax.js?config=TeX-AMS-MML_HTMLorMML');
        d.getElementsByTagName('head')[0].appendChild(script);
    }(document));
</script>
</body>
</html>
